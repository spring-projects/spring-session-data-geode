= Spring Session
John Blum
:data-store-version: 16
:data-store-name: Apache Geode
:data-store-docs: http://geode.apache.org/docs/guide/{data-store-version}
:data-store-javadoc: http://geode.apache.org/releases/latest/javadoc
:data-store-website: http://geode.apache.org
:sdg-name: Spring Data for {data-store-name}
:sdg-docs: https://docs.spring.io/spring-data/geode/docs/current/reference/html
:sdg-javadoc: https://docs.spring.io/spring-data/geode/docs/current/api
:doctype: book
:toc: left

[[abstract]]

Spring Session provides an API and implementations for managing a user's session information.

[[introduction]]
== Introduction

Spring Session provides an API and implementations for managing a user's session information.
It also provides transparent integration with:

** **HttpSession** - enables the `HttpSession` to be <<httpsession-gemfire,clustered>> (i.e. replicated
for highly availability) without being tied to an application container specific solution.
** **REST API** - allows the session ID to be provided in the protocol header to work with RESTful APIs.
** **WebSocket** - provides the ability to keep the `HttpSession` alive when receiving WebSocket messages.
** **WebSession** - allows replacing the Spring WebFlux's `WebSession` in an application container neutral way.

In a nutshell, Spring Session replaces the `javax.servlet.http.HttpSession` in an application container neutral way
by supplying a more common and robust session implementation backing the `HttpSession`.

[[samples]]
== Samples and Guides (Start Here)

If you are looking to get started with Spring Session right of way, the best place to start
is with our Sample Applications.

.Sample Application using Spring Boot
|===
| Source | Description | Guide

| {gh-samples-url}boot/gemfire[HttpSession with Spring Boot and {data-store-name}]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} in a Spring Boot application
using a Client/Server topology.
| link:guides/boot-gemfire.html[HttpSession with Spring Boot and {data-store-name} Guide]

| {gh-samples-url}boot/gemfire-with-scoped-proxies[HttpSession with Spring Boot and {data-store-name} using Scoped Proxies]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} in a Spring Boot application
using a Client/Server topology.  The application also makes use of Spring Request and Session Scoped Proxy beans.
| link:guides/boot-gemfire-with-scoped-proxies.html[HttpSession with Spring Boot and {data-store-name} using Scoped Proxies Guide]

|===

.Sample Applications using _Spring's_ Java-based configuration
|===
| Source | Description | Guide

| {gh-samples-url}javaconfig/gemfire-clientserver[HttpSession with {data-store-name} (Client/Server)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a Client/Server topology.
| link:guides/java-gemfire-clientserver.html[HttpSession with {data-store-name} (Client/Server) Guide]

| {gh-samples-url}javaconfig/gemfire-p2p[HttpSession with {data-store-name} (P2P)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a P2P topology.
| link:guides/java-gemfire-p2p.html[HttpSession with {data-store-name} (P2P) Guide]

|===

.Sample Applications using _Spring's_ XML-based configuration
|===
| Source | Description | Guide

| {gh-samples-url}xml/gemfire-clientserver[HttpSession with {data-store-name} (Client/Server)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a Client/Server topology.
| link:guides/xml-gemfire-clientserver.html[HttpSession with {data-store-name} (Client/Server) Guide]

| {gh-samples-url}xml/gemfire-p2p[HttpSession with {data-store-name} (P2P)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a P2P topology.
| link:guides/xml-gemfire-p2p.html[HttpSession with {data-store-name} (P2P) Guide]

|===

[[httpsession]]
== HttpSession Integration

Spring Session provides transparent integration with `javax.servlet.http.HttpSession`. This means that developers
can replace the `HttpSession` implementation with an implementation that is backed by Spring Session.

Spring Session enables multiple different data store providers (e.g. like {data-store-name}) to be plugged in
in order to manage the `HttpSession` state.

[[httpsession-why]]
=== Why Spring Session & HttpSession?

We already mentioned that Spring Session provides transparent integration with `HttpSession`, but what benefits
do we get out of this?

** **HttpSession** - enables the `HttpSession` to be <<httpsession-gemfire,clustered>> (i.e. replicated
for highly availability) without being tied to an application container specific solution.
** **REST API** - allows the session ID to be provided in the protocol header to work with RESTful APIs.
** **WebSocket** - provides the ability to keep the `HttpSession` alive when receiving WebSocket messages.
** **WebSession** - allows replacing the Spring WebFlux's `WebSession` in an application container neutral way.

[[httpsession-gemfire]]
=== HttpSession with {data-store-name}

When {data-store-website}[{data-store-name}] is used with Spring Session, a web application's
`javax.servlet.http.HttpSession` can be replaced with a **clustered** implementation managed by {data-store-name}
and conveniently accessed using Spring Session's API.

The two most common topologies for managing session state using {data-store-name} include:

* <<httpsession-gemfire-clientserver,Client-Server>>
* <<httpsession-gemfire-p2p,Peer-To-Peer (P2P)>>

Additionally, {data-store-name} supports site-to-site replication using the
{data-store-docs}/topologies_and_comm/multi_site_configuration/chapter_overview.html[WAN topology].
The ability to configure and use {data-store-name}'s WAN functionality is independent of Spring Session,
and beyond the scope of this document.

More details on configuring {data-store-name} WAN functionality using Spring Data for {data-store-name}
can be found {sdg-docs}/#bootstrap:gateway[here].

[[httpsession-gemfire-clientserver]]
==== {data-store-name} Client-Server

The {data-store-docs}/topologies_and_comm/cs_configuration/chapter_overview.html[Client-Server] topology will likely be
the most common configuration choice among users when using {data-store-name} as a provider in Spring Session since a
{data-store-name} server has significantly different and unique JVM heap requirements than compared to the application.
Using a Client-Server topology enables an application to manage (e.g. replicate) application state independently
from other application processes.

In a Client-Server topology, an application using Spring Session will open 1 or more connections to a remote cluster
of {data-store-name} servers that will manage access to all `HttpSession` state.

You can configure a Client-Server topology with either:

* <<httpsession-gemfire-clientserver-java,Java-based Configuration>>
* <<httpsession-gemfire-clientserver-xml,XML-based Configuration>>

[[httpsession-gemfire-clientserver-java]]
===== {data-store-name} Client-Server Java-based Configuration

This section describes how to configure {data-store-name}'s Client-Server topology to manage `HttpSession` state
with Java-based configuration.

NOTE: The <<samples,HttpSession with {data-store-name} (Client-Server)>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using Java configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (Client-Server) Guide_ when integrating with your own application.

include::guides/java-gemfire-clientserver.adoc[tags=config,leveloffset=+3]

[[http-session-gemfire-clientserver-xml]]
===== {data-store-name} Client-Server XML-based Configuration

This section describes how to configure {data-store-name}'s Client-Server topology to manage `HttpSession` state
with XML-based configuration.

NOTE: The <<samples,HttpSession with {data-store-name} (Client-Server) using XML>> provides a working sample
demonstrating how to integrate Spring Session with {data-store-name} to manage `HttpSession` state using XML
configuration. You can read through the basic steps of integration below, but you are encouraged to follow along
in the detailed _`HttpSession` with {data-store-name} (Client-Server) using XML Guide_ when integrating with
your own application.

include::guides/xml-gemfire-clientserver.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-p2p]]
==== {data-store-name} Peer-To-Peer (P2P)

A less common approach is to configure your Spring Session application as a peer member in the {data-store-name} cluster
using the {data-store-docs}/topologies_and_comm/p2p_configuration/chapter_overview.html[Peer-To-Peer (P2P)] topology.
In this configuration, the Spring Session application would be an actual server (or data node) in the {data-store-name}
cluster, and **not** just a cache client as before.

One advantage to this approach is the proximity of the application to the application's state (i.e. its data),
and in particular the `HttpSession` state. However, there are other effective means of accomplishing similar
data dependent computations, such as using {data-store-name}'s
{data-store-docs}/developing/function_exec/chapter_overview.html[Function Execution].
Any of {data-store-name}'s other {data-store-docs}/getting_started/product_intro.html[features] can be used when
{data-store-name} is serving as a provider in Spring Session.

The P2P topology is very useful for testing purposes and for smaller, more focused and self-contained applications,
such as those found in a microservices architecture, and will most certainly improve on your application's perceived
latency and throughput needs.

You can configure a Peer-To-Peer (P2P) topology with either:

* <<httpsession-gemfire-p2p-java,Java-based Configuration>>
* <<httpsession-gemfire-p2p-xml,XML-based Configuration>>

[[httpsession-gemfire-p2p-java]]
===== {data-store-name} Peer-To-Peer (P2P) Java-based Configuration

This section describes how to configure {data-store-name}'s Peer-To-Peer (P2P) topology to manage `HttpSession` state
using Java-based configuration.

NOTE: The <<samples, HttpSession with {data-store-name} (P2P)>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using Java configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (P2P) Guide_ when integrating with your own application.

include::guides/java-gemfire-p2p.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-p2p-xml]]
===== {data-store-name} Peer-To-Peer (P2P) XML-based Configuration

This section describes how to configure {data-store-name}'s Peer-To-Peer (P2P) topology to manage `HttpSession` state
using XML-based configuration.

NOTE: The <<samples, HttpSession with {data-store-name} (P2P) using XML>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using XML configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (P2P) using XML Guide_ when integrating with your own application.

include::guides/xml-gemfire-p2p.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-configuration-properties]]
=== Configuring `HttpSession` Management using {data-store-name} with Properties

While the `@EnableGemFireHttpSession` annotation is convenient and easy to use to get started quickly with
Spring Session and {data-store-name} in your Spring Boot applications, you quickly run into limitations when
migrating from 1 environment to another, for example, like when moving from DEV to QA to PROD.

With the `@EnableGemFireHttpSession` attributes, it is not possible to vary the configuration from 1 environment
to another.  Therefore, Spring Session for {data-store-name} introduces well-known properties for all
the `@EnableGemFireHttpSession` attributes.

[cols="2,2,2,1", options="header"]
.Well-known properties for the `@EnableGemFireHttpSession` attributes.
|===
| Property
| Annotation attribute
| Description
| Default

| spring.session.data.gemfire.cache.client.region.shortcut
| `EnableGemFireHttpSession.clientRegionShortcut`
| Sets the client Region data management policy in the client-server topology.
| ClientRegionShortcut.PROXY

| spring.session.data.gemfire.session.attributes.indexable
| `EnableGemFireHttpSession.indexableSessionAttributes`
| Comma-delimited list of Session attributes to indexed in the Session Region.
|

| spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds
| `EnableGemFireHttpSession.maxInactiveIntervalInSeconds`
| Session expiration timeout in seconds
| 1800

| spring.session.data.gemfire.cache.client.pool.name
| `EnableGemFireHttpSession.poolName`
| Name of the dedicated Pool used by the client Region storing/accessing Session state.
| gemfirePool

| spring.session.data.gemfire.session.region.name
| `EnableGemFireHttpSession.regionName`
| Name of the client or peer Region used to store and access Session state.
| ClusteredSpringSessions

| spring.session.data.gemfire.session.region.name
| `EnableGemFireHttpSession.serverRegionShortcut`
| Sets the peer Region data management policy in the peer-to-peer (P2P) topology.
| RegionShortcut.PARTITION

| spring.session.data.gemfire.session.serializer.bean-name
| `EnableGemFireHttpSession.sessionSerializerBeanName`
| Name of the bean in the Spring container implementing the serialization strategy
| SessionPdxSerializer
|===

TIP: All the properties are documented in the `@EnableGemFireHttpSession` attribute Javadoc as well.

Therefore, it is very simple to adjust the configuration of Spring Session when using {data-store-name}
as your provider by using properties, as follows:

[source,java]
----
@SpringBootApplication
@ClientCacheApplication
@EnableGemFireHttpSession(maxInactiveIntervalInSeconds = 900)
class MySpringSessionApplication {
  ...
}
----

And then, in `application.properties`:

[source,properties]
----
#application.properties
spring.session.data.gemfire.cache.client.region.shortcut=CACHING_PROXY
spring.session.data.gemfire.session.expiration.max-inactive-internval-seconds=3600
----

Any properties explicitly defined override the corresponding `@EnableGemFireHttpSession` attribute.  In the example
above, even though the `EnableGemFireHttpSession` annotation, `maxInactiveIntervalInSeconds` attribute was set to
`900` seconds, or 15 minutes, the corresponding attribute property
(`spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds`)
overrides the value and set the expiration to `3600` seconds, or 60 minutes.

NOTE: Keep in mind, properties override the annotation attribute values at runtime.

You can even get more sophisticated and configure your properties with other properties, as follows:

[source,properties]
----
#application.properties
spring.session.data.gemfire.session.expiration.max-inactive-internval-seconds=${app.geode.region.expiration.timeout:3600}
----

Additionally, you could use Spring profiles to vary the expiration timeout (or other properties) based on environment
or application, or whatever criteria your application requirements dictate.

NOTE: Property placeholders and nesting is a feature of the core Spring Framework and not specific to
Spring Session for {data-store-name}.

[[httpsession-gemfire-configuration-configurer]]
=== Configuring `HttpSession` Management using {data-store-name} with a Configurer

In addition to properties, Spring Session for {data-store-name} also allows you to adjust the configuration of
Spring Session with {data-store-name} using the `SpringSessionGemFireConfigurer` interface.  The interface defines a
default method for each `@EnableGemFireHttpSession` annotation attribute that can be overridden to adjust the
configuration.

The `SpringSessionGemFireConfigurer` is similar in concept to Spring Web MVC's Configurer implementations
(e.g. `o.s.web.servlet.config.annotation.WebMvcConfigurer`), which adjusts various aspects of your Web application's
configuration at runtime, such as configuring async support.  The advantage of delcaring and implementing a `Configurer`
is that it gives your programmatical control over your configuration.

For example, to adjust the client Region data management policy and Session expiration timeout as we did previously,
use the following:

[source,java]
----
@Configuration
class MySpringSessionConfiguration {

  @Bean
  SpringSessionGemFireConfigurer exampleSpringSessionGemFireConfigurer() {

    return new SpringSessionGemFireConfigurer() {

      @Override
      public ClientRegionShortcut getClientRegionShortcut() {
        return ClientRegionShortcut.CACHING_PROXY;
      }

      @Override
      public int getMaxInactiveIntervalInSeconds() {
        return 3600;
      }
    }
  }
}
----

Of course, the example above is not very creative.  You could most certainly use more sophisticated logic to determine
the configuration of each configuration attribute.

WARNING: Using the `SpringSessionGemFireConfigurer` is all or nothing.  Meaning, if you declare and use the `Configurer`,
then all configuration is derived from the configurer whether you overrode the appropriate method or not.  If you do not
override every method, then the default value for that configuration attribute will be used.

The `SpringSessionGemFireConfigurer` takes precedence over either the `@EnableGemFireHttpSession` annotation
attributes as well as any corresponding properties (e.g. `spring.session.data.gemfire.session.region.name`) defined
in `application.properties.`

Additionally, you can only declare 1 `SpringSessionGemFireConfigurer` bean in the Spring container at a time, unless
you are also using Spring profiles or have marked 1 of the multiple `SpringSessionGemFireConfigurer` beans as primary
using Spring's `@Primary` context annotation.

Of course, your `Configurer` could even be implemented in terms of other properties using Spring's `@Value` annotation,
as follows:

[source,java]
----
@Configuration
class MySpringSessionConfiguration {

  @Bean
  @Primary
  @Profile("production")
  SpringSessionGemFireConfigurer exampleSpringSessionGemFireConfigurer(
      @Value("${app.geode.region.data-management-policy:CACHING_PROXY}") ClientRegionShortcut shortcut,
      @Value("${app.geode.region.expiration.timeout:3600}") int timeout) {

    return new SpringSessionGemFireConfigurer() {

      @Override
      public ClientRegionShortcut getClientRegionShortcut() {
        return shortcut;
      }

      @Override
      public int getMaxInactiveIntervalInSeconds() {
        return timeout;
      }
    }
  }
}
----

TIP: Spring Boot will resolve `@Value` annotation property placeholder values or SpEL Expressions automatically.
However, if you are not using Spring Boot, then you must explicitly register a static
`PropertySourcesPlaceholderConfigurer` bean definition.

The choice is yours.

[[httpsession-gemfire-serialization]]
=== {data-store-name} Serialization

In order to transfer data between clients and servers, or when data is distributed and replicated between peer nodes
in a cluster, the data must be serialized.  In this case, the data in question is the Session's state.

Anytime a Session is persisted or accessed in a client/server topology, the Session's state is sent over-the-wire.
Typically, a Spring Boot application with Spring Session enabled will be a client to the server(s) in a cluster
of {data-store-name} nodes.

On the server-side, Session state maybe distributed across several servers (data nodes) in the cluster to replicate
the data and guarantee a high availability of the Session state.  When using {data-store-name}, data can be partitioned,
or sharded, and a redundancy-level can be specified.  When the data is distributed for replication, it must also be
serialized to transfer the Session state among the peer nodes in the cluster.

Out-of-the-box, {data-store-name} supports _Java Serialization_.  There are many advantages to _Java Serialization_,
such as handling cycles in the object graph, or being universally supported by any application written in Java.
However, _Java Serialization_ is very verbose and is not the most efficient over-the-wire format.

As such, {data-store-name} provides its own serialization frameworks to serialize Java types:

1. {data-store-docs}/developing/data_serialization/gemfire_data_serialization.html[Data Serialization]
2. {data-store-docs}/developing/data_serialization/gemfire_pdx_serialization.html[PDX Serialization]

[[httpsession-gemfire-serialization-background]]
==== {data-store-name} Serialization Background

As mentioned above, {data-store-name} provide 2 additional serialization frameworks:
_Data Serialization_ and PDX _Serialization_.

[[httpsession-gemfire-serialization-data]]
===== _Data Serialization_

_Data Serialization_ is a very efficient format (i.e. _fast_ and _compact_), with little overhead when compared to
_Java Serialization_.

It supports {data-store-docs}/developing/delta_propagation/chapter_overview.html[Delta Propagation] by sending
only the bits of data that actually changed as opposed to sending the entire object, which certainly cuts down
on the amount of data sent over the network in addition to reducing the amount of IO when data is persisted
or overflowed to disk.

However, _Data Serialization_ incurs a CPU penalty anytime data is transferred over-the-wire, or persisted/overflowed to
and accessed from disk, since the receiving end performs a deserialization.  In fact, anytime _Delta Propagation_
is used, the object must be deserialized on the receiving end in order to apply the "delta". {data-store-name} applies
deltas by invoking a method on the object that implements the `org.apache.geode.Delta` interface. Clearly, you cannot
invoke a method on a serialized object.

[[httpsession-gemfire-serialization-pdx]]
===== PDX

PDX, on the other hand, which stands for _Portable Data Exchange_, retains the form in which the data was sent.
For example, if a client sends data to a server in PDX format, the server will retain the data as PDX serialized bytes
and store them in the cache `Region` for which the data access operation was targeted.

Additionally, PDX, as the name implies, is "_portable_", meaning it enables both Java and Native Language Clients,
such as C, C++ and C# clients, to inter-operate on the same data set.

PDX even allows OQL queries to be performed on the serialized bytes without causing the objects to be deserialized
first in order to evaluate the query predicate and execute the query.  This can be accomplished since {data-store-name}
maintains a "_Type Registry_" containing type meta-data for the objects that get serialized and stored in
{data-store-name} using PDX.

However, portability does come with a cost, having slightly more overhead than _Data Serialization_. Still, PDX is far
more efficient and flexible than _Java Serialization_, which stores type meta-data in the serialized bytes of the object
rather than in a separate Type Registry as in {data-store-name}'s case when using PDX.

PDX does not support Deltas.  Technically, a PDX serializable object can be used in _Delta Propagation_ by implementing
the {data-store-javadoc}/org/apache/geode/Delta.html[`org.apache.geode.Delta`] interface, and only the "delta" will be
sent, even in the context of PDX.  But then, the PDX serialized object must be deserialized to apply the delta.
Remember, a method is invoked to apply the delta, which defeats the purpose of using PDX in the first place.

When developing Native Clients (e.g. C++) that manage data in a {data-store-name} cluster, or even when mixing
Native Clients with Java clients, typically there will not be any associated Java types provided on the classpath
of the servers in the cluster.  With PDX, it is not necessary to provide the Java types on the classpath, and many
users who only develop and use Native Clients to access data stored in {data-store-name} will not provide any
Java types for their corresponding C/C++/C# types.

{data-store-name} also support JSON serialized to/from PDX.  In this case, it is very likely that Java types will not be
provided on the servers classpath since many different languages (e.g. JavaScript, Python, Ruby) supporting JSON can be
used with {data-store-name}.

Still, even with PDX in play, users must take care not to cause a PDX serialized object on the servers in the cluster
to be deserialized.

For example, consider an OQL query on an object of the following Java type serialized as PDX...

[source, java]
----
@Region("People")
class Person {

  private LocalDate birthDate;
  private String name;

  public int getAge() {
    // no explicit 'age' field/property in Person
    // age is just implemented in terms of the 'birthDate' field
  }
}
----

Subsequently, if the OQL query invokes a method on a `Person` object, such as:

`SELECT * FROM /People p WHERE p.age >= 21`

Then, this is going to cause a PDX serialized `Person` object to be deserialized since `age` is not a field of `Person`,
but rather a method containing a computation based on another field of `Person` (i.e. `birthDate`).  Likewise, calling
any `java.lang.Object` method in a OQL query, like `Object.toString()`, is going to cause a deserialization to happen
as well.

{data-store-name} does provide the
{data-store-javadoc}/org/apache/geode/cache/client/ClientCacheFactory.html#setPdxReadSerialized-boolean-[`read-serialized`]
configuration setting so that any cache `Region.get(key)` operations that are potentially invoked inside a `Function`
does not cause PDX serialized objects to be deserialized.  But, nothing will prevent an ill-conceived OQL query from
causing a deserialization, so be careful.

[[httpsession-gemfire-serialization-java-data-pdx]]
===== PDX + _Data Serialization_ + _Java Serialization_

It is possible for {data-store-name} to support all 3 serialization formats simultaneously.

For instance, your application domain model might contain objects that implement the `java.io.Serialiable` interface,
and you may be using a combination of the _Data Serialization_ framework along with PDX.

TIP: While using _Java Serialization_ with _Data Serialization_ and PDX is possible, it is generally preferable
and recommended to use 1 serialization strategy.

NOTE: Unlike _Java Serialization_, _Data Serialization_ and PDX _Serialization_ do not handle object graph cycles.

More background on {data-store-name}'s serialization mechanics can be found
{data-store-docs}/developing/data_serialization/data_serialization_options.html[here].

[[httpsession-gemfire-serialization-spring-session]]
==== Serialization with Spring Session

Previously, Spring Session for {data-store-name} only supported {data-store-name} _Data Serialization_ format. The main
motivation behind this was to take advantage of {data-store-name}'s _Delta Propagation_ functionality since a Session's
state can be arbitrarily large.

However, as of Spring Session for {data-store-name} 2.0, PDX is also supported and is now the new, default serialization
option.  The default was changed to PDX in Spring Session for {data-store-name} 2.0 primarily because PDX is the most
widely used and requested format by users.

PDX is certainly the most flexible format, so much so that you do not even need Spring Session for {data-store-name}
or any of its transitive dependencies on the classpath of the servers in the cluster to use Spring Session with
{data-store-name}.  In fact, with PDX, you do not even need to put your application domain object types stored in
the (HTTP) Session on the servers' classpath either.

Essentially, when using PDX serialization, {data-store-name} does not require the associated Java types to be present
on the servers' classpath.  So long as no deserialization happens on the servers in the cluster, you are safe.

The `@EnableGemFireHttpSession` annotation introduces the **new** `sessionSerializerBeanName` attribute that a user
can use to configure the name of a bean declared and registered in the Spring container implementing the desired
serialization strategy.  The serialization strategy is used by Spring Session for {data-store-name} to serialize
the Session state.

Out-of-the-box, Spring Session for {data-store-name} provides 2 serialization strategies: 1 for PDX and 1 for
_Data Serialization_.  It automatically registers both serialization strategy beans in the Spring container.
However, only 1 of those strategies is actually used at runtime, PDX!

The 2 beans registered in the Spring container implementing _Data Serialization_ and PDX are named
`SessionDataSerializer` and `SessionPdxSerializer`, respectively. By default, the `sessionSerializerBeanName` attribute
is set to `SessionPdxSerializer`, as if the user annotated his/her Spring Boot, Spring Session enabled application
configuration class with:

[source, java]
----
@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = "SessionPdxSerializer")
class MySpringSessionApplication { .. }
----

It is a simple matter to change the serialization strategy to _Data Serialization_ instead by setting the
`sessionSerializerBeanName` attribute to `SessionDataSerializer`, as follows:

[source, java]
----
@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = "SessionDataSerializer")
class MySpringSessionApplication { .. }
----

Since these 2 values are so common, Spring Session for {data-store-name} provides constants for each value in the
`GemFireHttpSessionConfiguration` class: `GemFireHttpSessionConfiguration.SESSION_PDX_SERIALIZER_BEAN_NAME`
and `GemFireHttpSessionConfiguration.SESSION_DATA_SERIALIZER_BEAN_NAME`.  So, you could explicitly configure PDX,
as follows:

[source, java]
----
import org.springframework.session.data.geode.config.annotation.web.http.GemFireHttpSessionConfiguration;

@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = GemFireHttpSessionConfiguration.SESSION_PDX_SERIALIZER_BEAN_NAME)
class MySpringSessionApplication { .. }
----

With 1 attribute and 2 provided bean definitions out-of-the-box, you can specify which Serialization framework you wish
to use with your Spring Boot, Spring Session enabled application backed by {data-store-name}.

[[httpsession-gemfire-serialization-framework]]
==== Spring Session for {data-store-name} Serialization Framework

To abstract away the details of {data-store-name}'s _Data Serialization_ and PDX _Serialization_ frameworks,
Spring Session for {data-store-name} provides its own Serialization framework (facade) wrapping {data-store-name}'s
Serialization frameworks.

The Serialization API exists under the `org.springframework.session.data.gemfire.serialization` package. The primary
interface in this API is the `org.springframework.session.data.gemfire.serialization.SessionSerializer`.

The interface is defined as:

.Spring Session `SessionSerializer` interface
[source, java]
----
interface SessionSerializer<T, IN, OUT> {

  void serialize(T session, OUT out);

  T deserialize(IN in);

  boolean canSerialize(Class<?> type);

  boolean canSerialize(Object obj) {
    // calls Object.getClass() in a null-safe way and then calls and returns canSerialize(:Class)
  }
}
----

Basically, the interface allows you to serialize and deserialize a Spring `Session` object.

The `IN` and `OUT` type parameters and corresponding method arguments of those types provide reference to the objects
responsible for writing the `Session` to a stream of bytes or reading the `Session` from a stream of bytes.  The actual
arguments will be type specific, based on the underlying {data-store-name} Serialization strategy configured.

For instance, when using {data-store-name}'s PDX _Serialization_ framework, `IN` and `OUT` will be instances of
`org.apache.geode.pdx.PdxReader` and `org.apache.geode.pdx.PdxWriter`, respectively.  When {data-store-name}'s
_Data Serialization_ framework has been configured, then `IN` and `OUT` will be instances of `java.io.DataInput`
and `java.io.DataOutput`, respectively.

These arguments are provided to the `SessionSerializer` implementation by the framework automatically, and as
previously mentioned, is based on the underlying {data-store-name} Serialization strategy configured.

Essentially, even though Spring Session for {data-store-name} provides a facade around {data-store-name}'s
Serialization frameworks, under-the-hood {data-store-name} still expects one of these Serialization frameworks
is being used to serialize data to/from {data-store-name}.

_So what purpose does the `SessionSerializer` interface really serve then?_

Effectively, it allows a user to customize what aspects of the Session's state actually gets serialized and stored
in {data-store-name}.  Application developers can provide their own custom, application-specific `SessionSerializer`
implementation, register it as a bean in the Spring container, and then configure it to be used by Spring Session
for {data-store-name} to serialize the Session state, as follows:

[source, java]
----
@EnableGemFireHttpSession(sessionSerializerBeanName = "MyCustomSessionSerializer")
class MySpringSessionDataGemFireApplication {

  @Bean("MyCustomSessionSerializer")
  SessionSerializer<Session, ?, ?> myCustomSessionSerializer() {
    ...
  }
}
----

[[httpsession-gemfire-serialization-framework-serializer-implementation]]
===== Implementing a SessionSerializer

Spring Session for {data-store-name} provides assistance when a user wants to implement a custom `SessionSerializer`
that fits into one of {data-store-name}'s Serialization frameworks.

If the user just implements the `org.springframework.session.data.gemfire.serialization.SessionSerializer` interface
directly without extending from one of Spring Session for {data-store-name}'s provided abstract base classes, related
to 1 of {data-store-name}'s Serialization frameworks , then Spring Session for {data-store-name} will wrap the user's
custom `SessionSerializer` implementation in an instance of
`org.springframework.session.data.gemfire.serialization.pdx.support.PdxSerializerSessionSerializerAdapter`
and register it with {data-store-name} as a `org.apache.geode.pdx.PdxSerializer`.

Spring Session for {data-store-name} is careful not to stomp on any existing `PdxSerializer` implementation that a user
may have already registered with {data-store-name} by some other means.  Indeed, several different, provided
implementations of {data-store-name}'s `org.apache.geode.pdx.PdxSerializer` interface exists:

* {data-store-name} itself provides the
{data-store-javadoc}/org/apache/geode/pdx/ReflectionBasedAutoSerializer.html[`org.apache.geode.pdx.ReflectionBasedAutoSerializer`].

* Spring Data for {data-store-name} (SDG) provides the
{sdg-javadoc}/org/springframework/data/gemfire/mapping/MappingPdxSerializer.html[`org.springframework.data.gemfire.mapping.MappingPdxSerializer`],
which is used in the SD _Repository_ abstraction and SDG's extension to handle mapping PDX serialized types to
the application domain object types defined in the application _Repository_ interfaces.

This is accomplished by obtaining any currently registered `PdxSerializer` instance on the cache and composing it
with the `PdxSerializerSessionSerializerAdapter` wrapping the user's custom application `SessionSerializer`
implementation and re-registering this "_composite_" `PdxSerializer` on the {data-store-name} cache.  The "_composite_"
`PdxSerializer` implementation is provided Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.pdx.support.ComposablePdxSerializer` class
when entities are stored in {data-store-name} as PDX.

If no other `PdxSerializer` was currently registered with the {data-store-name} cache, then the adapter
is simply registered.

Of course, you are allowed to force the underlying {data-store-name} Serialization strategy used with a custom
`SessionSerializer` implementation by doing 1 of the following:

1. The custom `SessionSerializer` implementation can implement {data-store-name}'s `org.apache.geode.pdx.PdxSerializer`
interface, or for convenience, extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.pdx.AbstractPdxSerializableSessionSerializer` class
and Spring Session for {data-store-name} will register the custom `SessionSerializer` as a `PdxSerializer`
with {data-store-name}.

2. The custom `SessionSerializer` implementation can extend the {data-store-name}'s `org.apache.geode.DataSerializable`
class, or for convenience, extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.data.AbstractDataSerializableSessionSerializer` class
and Spring Session for {data-store-name} will register the custom `SessionSerializer` as a `DataSerializer`
with {data-store-name}.

3. Finally, a user can create a custom `SessionSerializer` implementation as before, not specifying which
{data-store-name} Serialization framework to use because the custom `SessionSeriaizer` implementation does not implement
any {data-store-name} serialization interfaces or extend from any of Spring Session for {data-store-name}'s provided
abstract base classes, and still have it registered in {data-store-name} as a `DataSerializer` by declaring an
additional Spring Session for {data-store-name} bean in the Spring container of type
`org.springframework.session.data.gemfire.serialization.data.support.DataSerializerSessionSerializerAdapter`, like so...

.Forcing the registration of a custom SessionSerializer as a DataSerializer in {data-store-name}
[source, java]
----
@EnableGemFireHttpSession(sessionSerializerBeanName = "customSessionSerializer")
class Application {

	@Bean
	DataSerializerSessionSerializerAdapter dataSerializerSessionSerializer() {
		return new DataSerializerSessionSerializerAdapter();
	}

	@Bean
	SessionSerializer<Session, ?, ?> customSessionSerializer() {
		...
	}
}
----

Just by the very presence of the `DataSerializerSessionSerializerAdapter` registered as a bean in the Spring container,
any neutral custom `SessionSerializer` implementation will be treated and registered as a `DataSerializer`
in {data-store-name}.

[[httpsession-gemfire-serialization-framework-session-representation]]
===== Changing the Session Representation

Internally, Spring Session for {data-store-name} maintains 2 representations of the (HTTP) Session and the Session's
attributes.  Each representation is based on whether {data-store-name} "_Deltas_" are supported or not.

{data-store-name} _Delta Propagation_ is only enabled by Spring Session for {data-store-name} when using
_Data Serialization_ for reasons that were discussed <<httpsession-gemfire-serialization-pdx, earlier>>.

Effectively, the strategy is:

1. If {data-store-name} _Data Serialization_ is configured, then _Deltas_ are supported and the
`DeltaCapableGemFireSession` and `DeltaCapableGemFireSessionAttributes` representations are used.

2. If {data-store-name} PDX _Serialization_ is configured, then _Delta Propagation_ will be disabled
and the `GemFireSession` and `GemFireSessionAttributes` representations are used.

It is possible to override these internal representations used by Spring Session for {data-store-name}, and for users
to provide their own Session related types.  The only strict requirement is that the Session implementation
must implement the core Spring Session `org.springframework.session.Session` interface.

By way of example, let's say you want to define your own Session implementation.

First, you define the `Session` type.  Perhaps your custom `Session` type even encapsulates and handles the Session
attributes without having to define a separate type.

.User-defined Session interface implementation
[source, java]
----
class MySession implements org.springframework.session.Session {
  ...
}
----

Then, you would need to extend the `org.springframework.session.data.gemfire.GemFireOperationsSessionRepository` class
and override the `createSession()` method to create instances of your custom `Session` implementation class.

.Custom SessionRepository implementation creating and returning instances of the custom Session type
[source, java]
----
class MySessionRepository extends GemFireOperationsSessionRepository {

  @Override
  public Session createSession() {
    return new MySession();
  }
}
----

If you provide your own custom `SessionSerializer` implementation and {data-store-name} PDX _Serialization_ is
configured, then you done.

However, if you configured {data-store-name} _Data Serialization_ then you must additionally provide a custom
implementation of the `SessionSerializer` interface and either have it directly extend {data-store-name}'s
`org.apache.geode.DataSerializer` class, or extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.data.AbstractDataSerializableSessionSerializer` class
and override the `getSupportedClasses():Class<?>[]` method.

For example:

.Custom SessionSerializer for custom Session type
[source, java]
----
class MySessionSerializer extends AbstractDataSerializableSessionSerializer {

  @Override
  public Class<?>[] getSupportedClasses() {
    return new Class[] { MySession.class };
  }

  ...
}
----

Unfortunately, `getSupportedClasses()` cannot return the generic Spring Session `org.springframework.session.Session`
interface type.  If it could then we could avoid the explicit need to override the `getSupportedClasses()` method on
the custom `DataSerializer` implementation.  But, {data-store-name}'s _Data Serialization_ framework  can only match
on exact class types since it incorrectly and internally stores and refers to the class type by name, which then
requires the user to override and implement the `getSupportedClasses()` method.

[[httpsession-how]]
=== How HttpSession Integration Works

Fortunately, both `javax.servlet.http.HttpSession` and `javax.servlet.http.HttpServletRequest` (the API for
obtaining an `HttpSession`) are interfaces. This means we can provide our own implementations for each of these APIs.

NOTE: This section describes how Spring Session provides transparent integration with `javax.servlet.http.HttpSession`.
The intent is so users understand what is happening under-the-hood. This functionality is already implemented
and integrated so you do not need to implement this logic yourself.

First, we create a custom `javax.servlet.http.HttpServletRequest` that returns a custom implementation of
`javax.servlet.http.HttpSession`.  It looks something like the following:

[source, java]
----
public class SessionRepositoryRequestWrapper extends HttpServletRequestWrapper {

	public SessionRepositoryRequestWrapper(HttpServletRequest original) {
		super(original);
	}

	public HttpSession getSession() {
		return getSession(true);
	}

	public HttpSession getSession(boolean createNew) {
		// create an HttpSession implementation from Spring Session
	}

	// ... other methods delegate to the original HttpServletRequest ...
}
----

Any method that returns an `javax.servlet.http.HttpSession` is overridden.  All other methods are implemented by
`javax.servlet.http.HttpServletRequestWrapper` and simply delegate to the original
`javax.servlet.http.HttpServletRequest` implementation.

We replace the `javax.servlet.http.HttpServletRequest` implementation using a Servlet `Filter` called
`SessionRepositoryFilter`. The pseudocode can be found below:

[source, java]
----
public class SessionRepositoryFilter implements Filter {

	public doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {

		HttpServletRequest httpRequest = (HttpServletRequest) request;

		SessionRepositoryRequestWrapper customRequest = new SessionRepositoryRequestWrapper(httpRequest);

		chain.doFilter(customRequest, response, chain);
	}

	// ...
}
----

By passing in a custom `javax.servlet.http.HttpServletRequest` implementation into the `FilterChain` we ensure that
anything invoked after our `Filter` uses the custom `javax.servlet.http.HttpSession` implementation.

This highlights why it is important that Spring Session's `SessionRepositoryFilter` must be placed before anything
that interacts with the `javax.servlet.http.HttpSession`.

[[httpsession-httpsessionlistener]]
=== HttpSessionListener

Spring Session supports `HttpSessionListener` by translating `SessionCreatedEvent` and `SessionDestroyedEvent` into
`HttpSessionEvent` by declaring `SessionEventHttpSessionListenerAdapter`.

To use this support, you need to:

* Ensure your `SessionRepository` implementation supports and is configured to fire `SessionCreatedEvent`
and`SessionDestroyedEvent`.
* Configure `SessionEventHttpSessionListenerAdapter` as a Spring bean.
* Inject every `HttpSessionListener` into the `SessionEventHttpSessionListenerAdapter`

If you are using the configuration support documented in <<httpsession-gemfire,HttpSession with {data-store-name}>>,
then all you need to do is register every `HttpSessionListener` as a bean.

For example, assume you want to support Spring Security's concurrency control and need to use `HttpSessionEventPublisher`,
then you can simply add `HttpSessionEventPublisher` as a bean.

[[api-session]]
=== Session

A `Session` is a simplified `Map` of key/value pairs with support for expiration.

[[api-sessionrepository]]
=== SessionRepository

A `SessionRepository` is in charge of creating, persisting and accessing `Session` instances and state.

If possible, developers should not interact directly with a `SessionRepository` or a `Session`.  Instead, developers
should prefer to interact with `SessionRepository` and `Session` indirectly through the `javax.servlet.http.HttpSession`,
`WebSocket` and `WebSession` integration.

[[api-findbyindexnamesessionrepository]]
=== FindByIndexNameSessionRepository

Spring Session's most basic API for using a `Session` is the `SessionRepository`.  The API is intentionally very simple
so that it is easy to provide additional implementations with basic functionality.

Some `SessionRepository` implementations may choose to implement `FindByIndexNameSessionRepository` also.
For example, Spring Session's for {data-store-name} support implements `FindByIndexNameSessionRepository`.

The `FindByIndexNameSessionRepository` adds a single method to look up all the sessions for a particular user.
This is done by ensuring that the session attribute with the name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`
is populated with the username. It is the responsibility of the developer to ensure the attribute is populated since
Spring Session is not aware of the authentication mechanism being used.

[NOTE]
====
Some implementations of `FindByIndexNameSessionRepository` will provide hooks to automatically index other session attributes.
For example, many implementations will automatically ensure the current Spring Security user name is indexed with
the index name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`.
====

[[api-enablespringhttpsession]]
=== EnableSpringHttpSession

The `@EnableSpringHttpSession` annotation can be added to any `@Configuration` class to expose the
`SessionRepositoryFilter` as a bean in the Spring container named, "springSessionRepositoryFilter".

In order to leverage the annotation, a single `SessionRepository` bean must be provided.

[[api-enablegemfirehttpsession]]
=== EnableGemFireHttpSession

The `@EnableGemFireHttpSession` annotation can be added to any `@Configuration` class in place of the
`@EnableSpringHttpSession` annotation to expose the `SessionRepositoryFilter` as a bean in the Spring container named,
"springSessionRepositoryFilter" and to position {data-store-name} as a provider managing `javax.servlet.http.HttpSession`
state.

When using the `@EnableGemFireHttpSession` annotation, additional configuration is imported out-of-the-box that also
provides a {data-store-name} specific implementation of the `SessionRepository` interface named,
`GemFireOperationsSessionRepository`.

[[api-gemfireoperationssessionrepository]]
=== GemFireOperationsSessionRepository

`GemFireOperationsSessionRepository` is a `SessionRepository` implementation that is implemented using Spring Session
for {data-store-name}'s_ `GemFireOperationsSessionRepository`.

In a web environment, this repository is used in conjunction with the `SessionRepositoryFilter`.

This implementation supports `SessionCreatedEvents`, `SessionDeletedEvents` and `SessionDestroyedEvents`
through `SessionEventHttpSessionListenerAdapter`.

[[api-gemfireoperationssessionrepository-indexing]]
==== Using Indexes with {data-store-name}

While best practices concerning the proper definition of Indexes that positively impact {data-store-name}'s performance
is beyond the scope of this document, it is important to realize that Spring Session for {data-store-name} creates
and uses Indexes to query and find Sessions efficiently.

Out-of-the-box, Spring Session for {data-store-name} creates 1 Hash-typed Index on the principal name. There are two
different built-in strategies for finding the principal name. The first strategy is that the value of the Session
attribute with the name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME` will be Indexed to the same
index name.

For example:

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyindexname-set]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyindexname-get]
----

[[api-gemfireoperationssessionrepository-indexing-security]]
==== Using Indexes with {data-store-name} & Spring Security

Alternatively, Spring Session for {data-store-name} will map Spring Security's current `Authentication#getName()` to
the Index `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`.

For example, if you are using Spring Security you can find the current user's sessions using:

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyspringsecurityindexname-context]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyspringsecurityindexname-get]
----

[[api-gemfireoperationssessionrepository-indexing-custom]]
==== Using Custom Indexes with {data-store-name}

This enables developers using the `GemFireOperationsSessionRepository` programmatically to query and find all Sessions
with a given principal name efficiently.

Additionally, Spring Session for {data-store-name} will create a Range-based Index on the implementing Session's
Map-type `attributes` property (i.e. on any arbitrary Session attribute) when a developer identifies 1 or more
named Session attributes that should be indexed by {data-store-name}.

Sessions attributes to index can be specified with the `indexableSessionAttributes` attribute on the
`@EnableGemFireHttpSession` annotation.  A developer adds this annotation to their Spring application
`@Configuration` class when s/he wishes to enable Spring Session's support for `HttpSession` backed by
{data-store-name}.

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireCustomIndexingIntegrationTests.java[tags=findbyindexname-set]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireCustomIndexingIntegrationTests.java[tags=findbyindexname-get]
----

NOTE: Only Session attribute names identified in the `@EnableGemFireHttpSession` annotation's
`indexableSessionAttributes` attribute will have an Index defined.  All other Session attributes will not be indexed.

However, there is one catch. Any values stored in an indexable Session attributes must implement the
`java.lang.Comparable<T>` interface. If those object values do not implement `Comparable`, then {data-store-name}
will throw an error on startup when the Index is defined for Regions with persistent Session data, or when an attempt
is made at runtime to assign the indexable Session attribute a value that is not `Comparable` and the Session is saved
to {data-store-name}.

NOTE: Any Session attribute that is not indexed may store non-`Comparable` values.

To learn more about {data-store-name}'s Range-based Indexes, see
{data-store-docs}/developing/query_index/creating_map_indexes.html[Creating Indexes on Map Fields].

To learn more about {data-store-name} Indexing in general, see
{data-store-docs}/developing/query_index/query_index.html[Working with Indexes].

[[community]]
== Spring Session Community

We are glad to consider you a part of our community.
Please find additional information below.

[[community-support]]
=== Support

You can get help by asking questions on http://stackoverflow.com/questions/tagged/spring-session[StackOverflow with the tag `spring-session`].
Similarly we encourage helping others by answering questions on _StackOverflow_.

[[community-source]]
=== Source Code

The source code can be found on GitHub at https://github.com/spring-projects/spring-session-data-geode

[[community-issues]]
=== Issue Tracking

We track issues in GitHub Issues at https://github.com/spring-projects/spring-session-data-geode/issues

[[community-contributing]]
=== Contributing

We appreciate https://help.github.com/articles/using-pull-requests/[Pull Requests].

[[community-license]]
=== License

Spring Session for {data-store-name} and Spring Session for Pivotal GemFire are Open Source Software
released under the http://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 license].

[[minimum-requirements]]
== Minimum Requirements

The minimum requirements for Spring Session are:

* Java 8+
* If you are running in a Servlet container (not required), Servlet 2.5+
* If you are using other Spring libraries (not required), the minimum required version is Spring Framework 5.0.x.
* `@EnableGemFireHttpSession` requires Spring Data for {data-store-name} 2.0.x and Spring Data for Pivotal GemFire 2.0.x.
* `@EnableGemFireHttpSession` requires {data-store-name} 1.2.x or Pivotal GemFire 9.1.x.

[NOTE]
====
At its core Spring Session only has a required dependency on `spring-jcl`.
====

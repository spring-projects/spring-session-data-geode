= Spring Session
John Blum
:data-store-version: 16
:data-store-name: Apache Geode
:data-store-docs: http://geode.apache.org/docs/guide/{data-store-version}
:data-store-javadoc: http://geode.apache.org/releases/latest/javadoc
:data-store-website: http://geode.apache.org
:sdg-name: Spring Data for {data-store-name}
:sdg-docs: https://docs.spring.io/spring-data/geode/docs/current/reference/html
:sdg-javadoc: https://docs.spring.io/spring-data/geode/docs/current/api
:doctype: book
:toc: left

[[abstract]]

Spring Session provides an API and implementations for managing a user's session information.

[[introduction]]
== Introduction

Spring Session provides an API and implementations for managing a user's session information.
It also provides transparent integration with:

** **HttpSession** - enables the `HttpSession` to be <<httpsession-gemfire,clustered>> (i.e. replicated
for highly availability) without being tied to an application container specific solution.
** **REST API** - allows the session ID to be provided in the protocol header to work with RESTful APIs.
** **WebSocket** - provides the ability to keep the `HttpSession` alive when receiving WebSocket messages.
** **WebSession** - allows replacing the Spring WebFlux's `WebSession` in an application container neutral way.

In a nutshell, Spring Session replaces the `javax.servlet.http.HttpSession` in an application container neutral way
by supplying a more common and robust session implementation backing the `HttpSession`.

[[samples]]
== Samples and Guides (Start Here)

If you are looking to get started with Spring Session right of way, the best place to start
is with our Sample Applications.

.Sample Application using Spring Boot
|===
| Source | Description | Guide

| {gh-samples-url}boot/gemfire[HttpSession with Spring Boot and {data-store-name}]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} in a Spring Boot application
using a Client/Server topology.
| link:guides/boot-gemfire.html[HttpSession with Spring Boot and {data-store-name} Guide]

| {gh-samples-url}boot/gemfire-with-gfsh-servers[HttpSession with Spring Boot and {data-store-name} using Gfsh]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} in a Spring Boot application
using a Client/Server topology.  Additionally configures and uses {data-store-name}'s _DataSerialization_ framework.
| link:guides/boot-gemfire-with-gfsh-servers.html[HttpSession with Spring Boot and {data-store-name} using Gfsh Guide]

| {gh-samples-url}boot/gemfire-with-scoped-proxies[HttpSession with Spring Boot and {data-store-name} using Scoped Proxies]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} in a Spring Boot application
using a Client/Server topology.  The application also makes use of Spring Request and Session Scoped Proxy beans.
| link:guides/boot-gemfire-with-scoped-proxies.html[HttpSession with Spring Boot and {data-store-name} using Scoped Proxies Guide]

|===

.Sample Applications using _Spring's_ Java-based configuration
|===
| Source | Description | Guide

| {gh-samples-url}javaconfig/gemfire-clientserver[HttpSession with {data-store-name} (Client/Server)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a Client/Server topology.
| link:guides/java-gemfire-clientserver.html[HttpSession with {data-store-name} (Client/Server) Guide]

| {gh-samples-url}javaconfig/gemfire-p2p[HttpSession with {data-store-name} (P2P)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a P2P topology.
| link:guides/java-gemfire-p2p.html[HttpSession with {data-store-name} (P2P) Guide]

|===

.Sample Applications using _Spring's_ XML-based configuration
|===
| Source | Description | Guide

| {gh-samples-url}xml/gemfire-clientserver[HttpSession with {data-store-name} (Client/Server)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a Client/Server topology.
| link:guides/xml-gemfire-clientserver.html[HttpSession with {data-store-name} (Client/Server) Guide]

| {gh-samples-url}xml/gemfire-p2p[HttpSession with {data-store-name} (P2P)]
| Demonstrates how to use Spring Session to manage the `HttpSession` with {data-store-name} using a P2P topology.
| link:guides/xml-gemfire-p2p.html[HttpSession with {data-store-name} (P2P) Guide]

|===

[[httpsession]]
== HttpSession Integration

Spring Session provides transparent integration with `javax.servlet.http.HttpSession`. This means that developers
can replace the `HttpSession` implementation with an implementation that is backed by Spring Session.

Spring Session enables multiple different data store providers (e.g. like {data-store-name}) to be plugged in
in order to manage the `HttpSession` state.

[[httpsession-why]]
=== Why Spring Session & HttpSession?

We already mentioned that Spring Session provides transparent integration with `HttpSession`, but what benefits
do we get out of this?

** **HttpSession** - enables the `HttpSession` to be <<httpsession-gemfire,clustered>> (i.e. replicated
for highly availability) without being tied to an application container specific solution.
** **REST API** - allows the session ID to be provided in the protocol header to work with RESTful APIs.
** **WebSocket** - provides the ability to keep the `HttpSession` alive when receiving WebSocket messages.
** **WebSession** - allows replacing the Spring WebFlux's `WebSession` in an application container neutral way.

[[httpsession-gemfire]]
=== HttpSession Management with {data-store-name}

When {data-store-website}[{data-store-name}] is used with Spring Session, a web application's
`javax.servlet.http.HttpSession` can be replaced with a **clustered** implementation managed by {data-store-name}
and conveniently accessed using Spring Session's API.

The two most common topologies for managing session state using {data-store-name} include:

* <<httpsession-gemfire-clientserver,Client-Server>>
* <<httpsession-gemfire-p2p,Peer-To-Peer (P2P)>>

Additionally, {data-store-name} supports site-to-site replication using the
{data-store-docs}/topologies_and_comm/multi_site_configuration/chapter_overview.html[WAN topology].
The ability to configure and use {data-store-name}'s WAN functionality is independent of Spring Session,
and beyond the scope of this document.

More details on configuring {data-store-name} WAN functionality using Spring Data for {data-store-name}
can be found {sdg-docs}/#bootstrap:gateway[here].

[[httpsession-gemfire-clientserver]]
==== {data-store-name} Client-Server

The {data-store-docs}/topologies_and_comm/cs_configuration/chapter_overview.html[Client-Server] topology will likely be
the most common configuration choice among users when using {data-store-name} as a provider in Spring Session since a
{data-store-name} server has significantly different and unique JVM heap requirements than compared to the application.
Using a Client-Server topology enables an application to manage (e.g. replicate) application state independently
from other application processes.

In a Client-Server topology, an application using Spring Session will open 1 or more connections to a remote cluster
of {data-store-name} servers that will manage access to all `HttpSession` state.

You can configure a Client-Server topology with either:

* <<httpsession-gemfire-clientserver-java,Java-based Configuration>>
* <<httpsession-gemfire-clientserver-xml,XML-based Configuration>>

[[httpsession-gemfire-clientserver-java]]
===== {data-store-name} Client-Server Java-based Configuration

This section describes how to configure {data-store-name}'s Client-Server topology to manage `HttpSession` state
with Java-based configuration.

NOTE: The <<samples,HttpSession with {data-store-name} (Client-Server)>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using Java configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (Client-Server) Guide_ when integrating with your own application.

include::guides/java-gemfire-clientserver.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-clientserver-xml]]
===== {data-store-name} Client-Server XML-based Configuration

This section describes how to configure {data-store-name}'s Client-Server topology to manage `HttpSession` state
with XML-based configuration.

NOTE: The <<samples,HttpSession with {data-store-name} (Client-Server) using XML>> provides a working sample
demonstrating how to integrate Spring Session with {data-store-name} to manage `HttpSession` state using XML
configuration. You can read through the basic steps of integration below, but you are encouraged to follow along
in the detailed _`HttpSession` with {data-store-name} (Client-Server) using XML Guide_ when integrating with
your own application.

include::guides/xml-gemfire-clientserver.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-p2p]]
==== {data-store-name} Peer-To-Peer (P2P)

A less common approach is to configure your Spring Session application as a peer member in the {data-store-name} cluster
using the {data-store-docs}/topologies_and_comm/p2p_configuration/chapter_overview.html[Peer-To-Peer (P2P)] topology.
In this configuration, the Spring Session application would be an actual server (or data node) in the {data-store-name}
cluster, and **not** just a cache client as before.

One advantage to this approach is the proximity of the application to the application's state (i.e. its data),
and in particular the `HttpSession` state. However, there are other effective means of accomplishing similar
data dependent computations, such as using {data-store-name}'s
{data-store-docs}/developing/function_exec/chapter_overview.html[Function Execution].
Any of {data-store-name}'s other {data-store-docs}/getting_started/product_intro.html[features] can be used when
{data-store-name} is serving as a provider in Spring Session.

The P2P topology is very useful for testing purposes and for smaller, more focused and self-contained applications,
such as those found in a microservices architecture, and will most certainly improve on your application's perceived
latency and throughput needs.

You can configure a Peer-To-Peer (P2P) topology with either:

* <<httpsession-gemfire-p2p-java,Java-based Configuration>>
* <<httpsession-gemfire-p2p-xml,XML-based Configuration>>

[[httpsession-gemfire-p2p-java]]
===== {data-store-name} Peer-To-Peer (P2P) Java-based Configuration

This section describes how to configure {data-store-name}'s Peer-To-Peer (P2P) topology to manage `HttpSession` state
using Java-based configuration.

NOTE: The <<samples, HttpSession with {data-store-name} (P2P)>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using Java configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (P2P) Guide_ when integrating with your own application.

include::guides/java-gemfire-p2p.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-p2p-xml]]
===== {data-store-name} Peer-To-Peer (P2P) XML-based Configuration

This section describes how to configure {data-store-name}'s Peer-To-Peer (P2P) topology to manage `HttpSession` state
using XML-based configuration.

NOTE: The <<samples, HttpSession with {data-store-name} (P2P) using XML>> provides a working sample demonstrating how to
integrate Spring Session with {data-store-name} to manage `HttpSession` state using XML configuration. You can read
through the basic steps of integration below, but you are encouraged to follow along in the detailed _`HttpSession`
with {data-store-name} (P2P) using XML Guide_ when integrating with your own application.

include::guides/xml-gemfire-p2p.adoc[tags=config,leveloffset=+3]

[[httpsession-gemfire-configuration-properties]]
=== Configuring `HttpSession` Management using {data-store-name} with Properties

While the `@EnableGemFireHttpSession` annotation is easy to use and convenient when getting started with Spring Session
and {data-store-name} in your Spring Boot applications, you quickly run into limitations when migrating from one
environment to another, for example, like when moving from DEV to QA to PROD.

With the `@EnableGemFireHttpSession` annotation attributes, it is not possible to vary the configuration from one
environment to another.  Therefore, Spring Session for {data-store-name} introduces well-known, documented properties
for all the `@EnableGemFireHttpSession` annotation attributes.

[cols="2,2,2,1", options="header"]
.Well-known, documented properties for the `@EnableGemFireHttpSession` annotation attributes.
|===
| Property
| Annotation attribute
| Description
| Default

| spring.session.data.gemfire.cache.client.pool.name
| `EnableGemFireHttpSession.poolName`
| Name of the dedicated Pool used by the client Region storing/accessing Session state.
| gemfirePool

| spring.session.data.gemfire.cache.client.region.shortcut
| `EnableGemFireHttpSession.clientRegionShortcut`
| Sets the client Region data management policy in the client-server topology.
| ClientRegionShortcut.PROXY

| spring.session.data.gemfire.cache.server.region.shortcut
| `EnableGemFireHttpSession.serverRegionShortcut`
| Sets the peer Region data management policy in the peer-to-peer (P2P) topology.
| RegionShortcut.PARTITION

| spring.session.data.gemfire.session.attributes.indexable
| `EnableGemFireHttpSession.indexableSessionAttributes`
| Comma-delimited list of Session attributes to indexed in the Session Region.
|

| spring.session.data.gemfire.session.expiration.bean-name
| `EnableGemFireHttpSession.sessionExpirationPolicyBeanName`
| Name of the bean in the Spring container implementing the expiration strategy
|

| spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds
| `EnableGemFireHttpSession.maxInactiveIntervalInSeconds`
| Session expiration timeout in seconds
| 1800

| spring.session.data.gemfire.session.region.name
| `EnableGemFireHttpSession.regionName`
| Name of the client or peer Region used to store and access Session state.
| ClusteredSpringSessions

| spring.session.data.gemfire.session.serializer.bean-name
| `EnableGemFireHttpSession.sessionSerializerBeanName`
| Name of the bean in the Spring container implementing the serialization strategy
| SessionPdxSerializer
|===

TIP: All the properties are documented in the `@EnableGemFireHttpSession` annotation attribute Javadoc as well.

Therefore, it is very simple to adjust the configuration of Spring Session when using {data-store-name}
as your provider by using properties, as follows:

[source,java]
----
@SpringBootApplication
@ClientCacheApplication
@EnableGemFireHttpSession(maxInactiveIntervalInSeconds = 900)
class MySpringSessionApplication {
  ...
}
----

And then, in `application.properties`:

[source,properties]
----
#application.properties
spring.session.data.gemfire.cache.client.region.shortcut=CACHING_PROXY
spring.session.data.gemfire.session.expiration.max-inactive-internval-seconds=3600
----

Any properties explicitly defined override the corresponding `@EnableGemFireHttpSession` annotation attribute.

In the example above, even though the `EnableGemFireHttpSession` annotation `maxInactiveIntervalInSeconds` attribute
was set to `900` seconds, or 15 minutes, the corresponding attribute property
(i.e. `spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds`)
overrides the value and sets the expiration to `3600` seconds, or 60 minutes.

NOTE: Keep in mind, properties override the annotation attribute values at runtime.

[[httpsession-gemfire-configuration-properties-of-properties]]
==== Properties of Properties

You can even get more sophisticated and configure your properties with other properties, as follows:

[source,properties]
----
#application.properties
spring.session.data.gemfire.session.expiration.max-inactive-internval-seconds=${app.geode.region.expiration.timeout:3600}
----

Additionally, you could use Spring profiles to vary the expiration timeout (or other properties) based on environment
or your application, or whatever criteria your application requirements dictate.

NOTE: Property placeholders and nesting is a feature of the core Spring Framework and not specific to Spring Session
or Spring Session for {data-store-name}.

[[httpsession-gemfire-configuration-configurer]]
=== Configuring `HttpSession` Management using {data-store-name} with a Configurer

In addition to properties, Spring Session for {data-store-name} also allows you to adjust the configuration of
Spring Session with {data-store-name} using the `SpringSessionGemFireConfigurer` interface.  The interface defines a
contract containing default methods for each `@EnableGemFireHttpSession` annotation attribute that can be overridden
to adjust the configuration.

The `SpringSessionGemFireConfigurer` is similar in concept to Spring Web MVC's Configurer interfaces
(e.g. `o.s.web.servlet.config.annotation.WebMvcConfigurer`), which adjusts various aspects of your Web application's
configuration on startup, such as configuring async support.  The advantage of declaring and implementing a `Configurer`
is that it gives you programmatical control over your configuration.  This is useful in situations where you need to
easily express complex, conditional logic that determines whether the configuration should be applied or not.

For example, to adjust the client Region data management policy and Session expiration timeout as we did previously,
use the following:

[source,java]
----
@Configuration
class MySpringSessionConfiguration {

  @Bean
  SpringSessionGemFireConfigurer exampleSpringSessionGemFireConfigurer() {

    return new SpringSessionGemFireConfigurer() {

      @Override
      public ClientRegionShortcut getClientRegionShortcut() {
        return ClientRegionShortcut.CACHING_PROXY;
      }

      @Override
      public int getMaxInactiveIntervalInSeconds() {
        return 3600;
      }
    }
  }
}
----

Of course, this example is not very creative.  You could most certainly use more complex logic to determine
the configuration of each configuration attribute.

You can be as sophisticated as you like, such as by implementing your `Configurer` in terms of other properties
using Spring's `@Value` annotation, as follows:

[source,java]
----
@Configuration
class MySpringSessionConfiguration {

  @Bean
  @Primary
  @Profile("production")
  SpringSessionGemFireConfigurer exampleSpringSessionGemFireConfigurer(
      @Value("${app.geode.region.data-management-policy:CACHING_PROXY}") ClientRegionShortcut shortcut,
      @Value("${app.geode.region.expiration.timeout:3600}") int timeout) {

    return new SpringSessionGemFireConfigurer() {

      @Override
      public ClientRegionShortcut getClientRegionShortcut() {
        return shortcut;
      }

      @Override
      public int getMaxInactiveIntervalInSeconds() {
        return timeout;
      }
    }
  }
}
----

TIP: Spring Boot will resolve `@Value` annotation property placeholder values or SpEL Expressions automatically.
However, if you are not using Spring Boot, then you must explicitly register a static
`PropertySourcesPlaceholderConfigurer` bean definition.

However, you can only declare 1 `SpringSessionGemFireConfigurer` bean in the Spring container at a time, unless
you are also using Spring profiles or have marked 1 of the multiple `SpringSessionGemFireConfigurer` beans as primary
by using Spring's `@Primary` context annotation.

[[httpsession-gemfire-configuration-configurer-precedence]]
==== Configuration Precedence

A `SpringSessionGemFireConfigurer` takes precedence over either the `@EnableGemFireHttpSession` annotation attributes
or any of the well-known and documented Spring Session for {data-store-name} properties
(e.g. `spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds`)
defined in Spring Boot `application.properties.`

If more than 1 configuration approach is employed by your Web application, the following precedence will apply:

1. `SpringSessionGemFireConfigurer` "implemented" callback methods
2. Documented Spring Session for {data-store-name} properties (See corresponding `@EnableGemFireHttpSession` annotation
attribute Javadoc; e.g. `spring.session.data.gemfire.session.region.name`)
3. `@EnableGemFireHttpSession` annotation attributes

Spring Session for {data-store-name} is careful to only apply configuration from a `SpringSessionGemFireConfigurer` bean
declared in the Spring container for the methods you have actually implemented.

In our example above, since you did not implement the `getRegionName()` method, the name of the {data-store-name} Region
managing the `HttpSession` state will not be determined by the Configurer.

[[httpsession-gemfire-configuration-configurer-precedence-example]]
===== Example

By way of example, consider the following configuration:

.Example Spring Session for {data-store-name} Configuration
[source,java]
----
@ClientCacheApplication
@EnableGemFireHttpSession(
    maxInactiveIntervalInSeconds = 3600,
    poolName = "DEFAULT"
}
class MySpringSessionConfiguration {

  @Bean
  SpringSessionGemFireConfigurer sessionExpirationTimeoutConfigurer() {

    return new SpringSessionGemFireConfigurer() {

      @Override
      public int getMaxInactiveIntervalInSeconds() {
        return 300;
      }
    }
  }
}
----

In addition, consider the following Spring Boot `application.properties` file:

. Spring Boot `application.properties`
[source,txt]
----
spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds = 900
spring.session.data.gemfire.session.region.name = Sessions
----

The Session expiration timeout will be 300 seconds, or 5 minutes, overriding both the property
(i.e. `spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds`) of 900 seconds, or 15 minutes,
as well as the explicit `@EnableGemFireHttpSession.maxInactiveIntervalInSeconds` annotation attribute value of
3600 seconds, or 1 hour.

Since the "sessionExpirationTimeoutConfigurer" bean does not override the `getRegionName()` method, the Session Region
name will be determined by the property (i.e. `spring.session.data.gemfire.session.region.name`), set to "Sessions",
which overrides the implicit `@EnableGemFireHttpSession.regionName` annotation attribute's default value of
"ClusteredSpringSessions".

The `@EnableGemFireHttpSession.poolName` annotation attribute's value of "DEFAULT" will determine the name of the Pool
used when sending Region operations between the client and server to manage Session state on the server(s) since neither
the corresponding property (i.e. spring.session.data.gemfire.cache.client.pool.name`) was set nor was
the `SpringSessionGemFireConfigurer.getPoolName()` method overridden by the "sessionExpirationTimeoutConfigurer" bean.

And finally, the client Region used to manage Session state will have a data management policy of `PROXY`, the default
value for the `@EnableGemFireHttpSession.clientRegionShortcut` annotation attribute, which was not explicitly set, nor
was the corresponding property (i.e. `spring.session.data.gemfire.cache.client.region.shortcut`) for this attribute.
And, because the `SpringSessionConfigurer.getClientRegionShortcut()` method was not overridden, the default value is used.

[[httpsession-gemfire-expiration]]
=== {data-store-name} Expiration

By default, {data-store-name} is configured with a Region Entry, Idle Timeout (TTI) Expiration Policy, using an
expiration timeout of 30 minutes and INVALIDATE entry as the action.  This means when a user's Session remains inactive
(i.e. idle) for more than 30 minutes, the Session will expire and is invalidated, and the user must begin a new Session
in order to continue to use the application.

However, what if you have application specific requirements around Session state management and expiration, and using
the default, Idle Timeout (TTI) Expiration Policy is insufficient for your Use Case (UC)?

Now, Spring Session for {data-store-name} supports application specific, custom expiration policies.  As an application
developer, you may specify custom rules governing the expiration of a Session managed by Spring Session, backed by
{data-store-name}.

Spring Session for {data-store-name} provides the new `SessionExpirationPolicy`
https://en.wikipedia.org/wiki/Strategy_pattern[_Strategy_] interface.

.SessionExpirationPolicy interface
[source,java]
----
@FunctionalInterface
interface SessionExpirationPolicy {

    // determine timeout for expiration of individual Session
    Optional<Duration> determineExpirationTimeout(Session session);

    // define the action taken on expiration
    default ExpirationAction getExpirationAction() {
        return ExpirationAction.INVALIDATE;
    }

    enum ExpirationAction {

        DESTROY,
        INVALIDATE

    }
}
----

You implement this interface to specify the Session expiration policies required by your application and then register
the instance as a bean in the Spring application context.

Use the `@EnableGemFireHttpSession` annotation, `sessionExpirationPolicyBeanName` attribute to configure the name of
the `SessionExpirationPolicy` bean implementing your custom application policies and rules for Session expiration.

For example:

.Custom `SessionExpirationPolicy`
[source,java]
----
class MySessionExpirationPolicy implements SessionExpirationPolicy {

    public Duration determineExpirationTimeout(Session session) {
        // return a java.time.Duration specifying the length of time until the Session should expire
    }
}
----

Then, in your application class, simple declare the following:

.Custom `SessionExpirationPolicy` configuration
[source,java]
----
@SpringBootApplication
@EnableGemFireHttpSession(
    maxInactiveIntervalInSeconds = 600,
    sessionExpirationPolicyBeanName = "expirationPolicy"
)
class MySpringSessionApplication {

    ...

    @Bean
    SessionExpirationPolicy expirationPolicy() {
        return new MySessionExpirationPolicy();
    }
}
----

TIP: Alternatively, the name of the `SessionExpirationPolicy` bean can be configured using the
`spring.session.data.gemfire.session.expiration.bean-name` property, or by declaring a `SpringSessionGemFireConfigurer`
bean in the Spring container and overriding the `getSessionExpirationPolicyBeanName()` method.

You are only required to implement the `determineExpirationTimeout(:Session):Optional<Duration>` method,
which encapsulates the rules to determine when the Session should expire.  The expiration timeout for a Session
is expressed as an `Optional` of `java.time.Duration`, which specifies the length of time until the Session expires.

The `determineExpirationTimeout` method can be Session specific and may change with each invocation.

Optionally, you may implement the `getAction` method to specify the action taken when the Session expires. By default,
the Region Entry (i.e. Session) is invalidated.  Another option is to destroy the Region Entry on expiration,
which removes both the key (Session ID) and value (Session).  Invalidate only removes the value.

NOTE: Under-the-hood, the `SessionExpirationPolicy` is adapted into an instance of the {data-store-name}
{data-store-javadoc}/org/apache/geode/cache/CustomExpiry.html[`CustomExpiry`] interface.
This Spring Session `CustomExpiry` object is then set as the Session Region's
{data-store-javadoc}/org/apache/geode/cache/RegionFactory.html#setCustomEntryIdleTimeout-org.apache.geode.cache.CustomExpiry-[custom entry idle timeout expiration policy].

NOTE: During expiration determination, the `CustomExpiry.getExpiry(:Region.Entry<String, Session>):ExpirationAttributes`
method is invoked for each entry (i.e. Session) in the Region every time the expiration thread(s) run, which in turn
calls our `SessionExpirationPolicy.determineExpirationTimout(:Session):Optional<Duration>` method.
The returned `java.time.Duration` is converted to seconds and used as the expiration timeout in the
{data-store-javadoc}/org/apache/geode/cache/ExpirationAttributes.html[`ExpirationAttributes`] returned from the
{data-store-javadoc}org/apache/geode/cache/CustomExpiry.html#getExpiry-org.apache.geode.cache.Region.Entry-[`CustomExpiry.getExpiry(..)`]
method invocation.

TIP: {data-store-name}'s expiration thread(s) run once every second, evaluating each entry (i.e. Session) in the Region
to determine if the entry has expired.  You can control the number of expiration threads with the `gemfire.EXPIRY_THREADS`
property.  See the {data-store-name} {data-store-docs}/developing/expiration/chapter_overview.html[docs] for more details.

[[httpsession-gemfire-expiration-timeout-configuration]]
==== Expiration Timeout Configuration

If you would like to base the expiration timeout for your custom `SessionExpirationPolicy` on
the `@EnableGemFireHttpSession` annotation, `maxInactiveIntervalInSeconds` attribute, or alternatively,
the corresponding `spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds` property,
then your custom `SessionExpirationPolicy` implementation may also implement the `SessionExpirationTimeoutAware`
interface.

The `SessionExpirationTimeoutAware` interface is defined as:

.SessionExpirationTimeoutAware interface
[source,java]
----
interface SessionExpirationTimeoutAware {

    void setExpirationTimeout(Duration expirationTimeout);

}
----

When your custom `SessionExpirationPolicy` implementation also implements the `SessionExpirationTimeoutAware` interface,
then Spring Session for {data-store-name} will supply your implementation with the value from the
`@EnableGemFireHttpSession` annotation, `maxInactiveIntervalInSeconds` attribute, or from the
`spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds` property if set, or from any
`SpringSessionGemFireConfigurer` bean declared in the Spring application context, as an instance of `java.time.Duration`.

If more than 1 configuration option is used, the following order takes precedence:

1. `SpringSessionGemFireConfigurer.getMaxInactiveIntervalInSeconds()`
2. `spring.session.data.gemfire.session.expiration.max-inactive-interval-seconds` property
3. `@EnableGemFireHttpSession` annotation, `maxInactiveIntervalInSeconds` attribute

[[httpsession-gemfire-expiration-fixed-timeout-configuration]]
==== Fixed Timeout Expiration

For added convenience, Spring Session for {data-store-name} provides an implementation of the `SessionExpirationPolicy`
interface for fixed duration expiration (or "_Absolute session timeouts_" as described in core Spring Session
https://github.com/spring-projects/spring-session/issues/922[Issue #922]).

It is perhaps necessary, in certain cases, such as for security reasons, to expire the user's Session after a fixed
length of time (e.g. every hour), regardless if the user's Session is still active.

Spring Session for {data-store-name} provides the `FixedTimeoutSessionExpirationPolicy` implementation out-of-the-box
for this exact Use Case (UC).  In addition to handling fixed duration expiration, it is also careful to still consider
and apply the default, idle expiration timeout.

For instance, consider a scenario where a user logs in, beginning a Session, is active for 10 minutes and then leaves
letting the Session sit idle. If the fixed duration expiration timeout is set for 60 minutes, but the idle expiration
timeout is only set for 30 minutes, and the user does not return, then the Session should expire in 40 minutes
and not 60 minutes when the fixed duration expiration would occur.

Conversely, if the user is busy for a full 40 minutes, thereby keeping the Session active, thus avoiding the 30 minute
idle expiration timeout, and then leaves, then our fixed duration expiration timeout should kick in and expire
the user's Session right at 60 minutes, even though the user's idle expiration timeout would not occur until 70 minutes
in (40 min (active) + 30 min (idle) = 70 minutes).

Well, this is exactly what the `FixedTimeoutSessionExpirationPolicy` does.

To configure the `FixedTimeoutSessionExpirationPolicy`, do the following:

.Fixed Duration Expiraton Configuration
[source,java]
----
@SpringBootApplication
@EnableGemFireHttpSession(sessionExpirationPolicyBeanName = "fixedTimeoutExpirationPolicy")
class MySpringSessionApplication {

    ...

    @Bean
    SessionExpirationPolicy fixedTimeoutExpirationPolicy() {
        return new FixedTimeoutSessionExpirationPolicy(Duration.ofMinutes(60L));
    }
}
----

In the example above, the `FixedTimeoutSessionExpirationPolicy` was declared as a bean in the Spring application context
and initialized with a fixed duration expiration timeout of 60 minutes.  As a result, the users Session will either
expire after the idle timeout (which defaults to 30 minutes) or after the fixed timeout (configured to 60 minutes),
which ever occurs first.

TIP: It is also possible to implement lazy, fixed duration expiration timeout on Session access by using the
Spring Session for {data-store-name} `FixedDurationExpirationSessionRepositoryBeanPostProcessor`.  This BPP wraps
any data store specific `SessionRepository` in a `FixedDurationExpirationSessionRepository` implementation
that evaluates a Sessions expiration on access, only.  This approach is agnostic to the underlying data store
and therefore can be used with any Spring Session provider.  The expiration determination is based solely on
the Session `creationTime` property and the required `java.time.Duration` specifying the fixed duration
expiration timeout.

CAUTION: The `FixedDurationExpirationSessionRepository` should not be used in strict expiration timeout cases, such as
when the Session must expire immediately after the fixed duration expiration timeout has elapsed.  Additionally, unlike
the `FixedTimeoutSessionExpirationPolicy`, the `FixedDurationExpirationSessionRepository` does not take idle expiration
timeout into consideration.  That is, it only uses the fixed duration when determining the expiration timeout
for a given Session.

[[httpsession-gemfire-expiration-policy-chaining]]
==== `SessionExpirationPolicy` Chaining

Using the https://en.wikipedia.org/wiki/Composite_pattern[Composite software design pattern], you can treat a group of
`SessionExpirationPolicy` instances as a single instance, functioning as if in a chain much like the chain of
Servlet Filters themselves.

The _Composite software design pattern_ is a powerful pattern and is supported by the `SessionExpirationPolicy`,
`@FunctionalInterface`, simply by returning an `Optional` of `java.time.Duration` from
the `determineExpirationTimeout` method.

This allows each composed `SessionExpirationPolicy` to "optionally" return a `Duration` only if the expiration
could be determined by this instance.  Alternatively, this instance may punt to the next `SessionExpirationPolicy`
in the composition, or chain until either a non-empty expiration timeout is returned, or ultimately
no expiration timeout is returned.

In fact, this very policy is used internally by the `FixedTimeoutSessionExpirationPolicy`, which will return
`Optional.empty()` in the case where the idle timeout will occur before the fixed timeout.  By returning
no expiration timeout, {data-store-name} will defer to the default, configured entry idle timeout expiration policy
on the Region managing Session state.

NOTE: This exact behavior is also documented in the
{data-store-javadoc}/org/apache/geode/cache/CustomExpiry.html#getExpiry-org.apache.geode.cache.Region.Entry-[`org.apache.geode.cache.CustomExpiry.getExpiry(:Region.Entry<String, Session>):ExpirationAttributes`] method.

[[httpsession-gemfire-serialization]]
=== {data-store-name} Serialization

In order to transfer data between clients and servers, or when data is distributed and replicated between peer nodes
in a cluster, the data must be serialized.  In this case, the data in question is the Session's state.

Anytime a Session is persisted or accessed in a client/server topology, the Session's state is sent over-the-wire.
Typically, a Spring Boot application with Spring Session enabled will be a client to the server(s) in a cluster
of {data-store-name} nodes.

On the server-side, Session state maybe distributed across several servers (data nodes) in the cluster to replicate
the data and guarantee a high availability of the Session state.  When using {data-store-name}, data can be partitioned,
or sharded, and a redundancy-level can be specified.  When the data is distributed for replication, it must also be
serialized to transfer the Session state among the peer nodes in the cluster.

Out-of-the-box, {data-store-name} supports _Java Serialization_.  There are many advantages to _Java Serialization_,
such as handling cycles in the object graph, or being universally supported by any application written in Java.
However, _Java Serialization_ is very verbose and is not the most efficient over-the-wire format.

As such, {data-store-name} provides its own serialization frameworks to serialize Java types:

1. {data-store-docs}/developing/data_serialization/gemfire_data_serialization.html[Data Serialization]
2. {data-store-docs}/developing/data_serialization/gemfire_pdx_serialization.html[PDX Serialization]

[[httpsession-gemfire-serialization-background]]
==== {data-store-name} Serialization Background

As mentioned above, {data-store-name} provide 2 additional serialization frameworks:
_Data Serialization_ and PDX _Serialization_.

[[httpsession-gemfire-serialization-data]]
===== _Data Serialization_

_Data Serialization_ is a very efficient format (i.e. _fast_ and _compact_), with little overhead when compared to
_Java Serialization_.

It supports {data-store-docs}/developing/delta_propagation/chapter_overview.html[Delta Propagation] by sending
only the bits of data that actually changed as opposed to sending the entire object, which certainly cuts down
on the amount of data sent over the network in addition to reducing the amount of IO when data is persisted
or overflowed to disk.

However, _Data Serialization_ incurs a CPU penalty anytime data is transferred over-the-wire, or persisted/overflowed to
and accessed from disk, since the receiving end performs a deserialization.  In fact, anytime _Delta Propagation_
is used, the object must be deserialized on the receiving end in order to apply the "delta". {data-store-name} applies
deltas by invoking a method on the object that implements the `org.apache.geode.Delta` interface. Clearly, you cannot
invoke a method on a serialized object.

[[httpsession-gemfire-serialization-pdx]]
===== PDX

PDX, on the other hand, which stands for _Portable Data Exchange_, retains the form in which the data was sent.
For example, if a client sends data to a server in PDX format, the server will retain the data as PDX serialized bytes
and store them in the cache `Region` for which the data access operation was targeted.

Additionally, PDX, as the name implies, is "_portable_", meaning it enables both Java and Native Language Clients,
such as C, C++ and C# clients, to inter-operate on the same data set.

PDX even allows OQL queries to be performed on the serialized bytes without causing the objects to be deserialized
first in order to evaluate the query predicate and execute the query.  This can be accomplished since {data-store-name}
maintains a "_Type Registry_" containing type meta-data for the objects that get serialized and stored in
{data-store-name} using PDX.

However, portability does come with a cost, having slightly more overhead than _Data Serialization_. Still, PDX is far
more efficient and flexible than _Java Serialization_, which stores type meta-data in the serialized bytes of the object
rather than in a separate Type Registry as in {data-store-name}'s case when using PDX.

PDX does not support Deltas.  Technically, a PDX serializable object can be used in _Delta Propagation_ by implementing
the {data-store-javadoc}/org/apache/geode/Delta.html[`org.apache.geode.Delta`] interface, and only the "delta" will be
sent, even in the context of PDX.  But then, the PDX serialized object must be deserialized to apply the delta.
Remember, a method is invoked to apply the delta, which defeats the purpose of using PDX in the first place.

When developing Native Clients (e.g. C++) that manage data in a {data-store-name} cluster, or even when mixing
Native Clients with Java clients, typically there will not be any associated Java types provided on the classpath
of the servers in the cluster.  With PDX, it is not necessary to provide the Java types on the classpath, and many
users who only develop and use Native Clients to access data stored in {data-store-name} will not provide any
Java types for their corresponding C/C++/C# types.

{data-store-name} also support JSON serialized to/from PDX.  In this case, it is very likely that Java types will not be
provided on the servers classpath since many different languages (e.g. JavaScript, Python, Ruby) supporting JSON can be
used with {data-store-name}.

Still, even with PDX in play, users must take care not to cause a PDX serialized object on the servers in the cluster
to be deserialized.

For example, consider an OQL query on an object of the following Java type serialized as PDX...

[source, java]
----
@Region("People")
class Person {

  private LocalDate birthDate;
  private String name;

  public int getAge() {
    // no explicit 'age' field/property in Person
    // age is just implemented in terms of the 'birthDate' field
  }
}
----

Subsequently, if the OQL query invokes a method on a `Person` object, such as:

`SELECT * FROM /People p WHERE p.age >= 21`

Then, this is going to cause a PDX serialized `Person` object to be deserialized since `age` is not a field of `Person`,
but rather a method containing a computation based on another field of `Person` (i.e. `birthDate`).  Likewise, calling
any `java.lang.Object` method in a OQL query, like `Object.toString()`, is going to cause a deserialization to happen
as well.

{data-store-name} does provide the
{data-store-javadoc}/org/apache/geode/cache/client/ClientCacheFactory.html#setPdxReadSerialized-boolean-[`read-serialized`]
configuration setting so that any cache `Region.get(key)` operations that are potentially invoked inside a `Function`
does not cause PDX serialized objects to be deserialized.  But, nothing will prevent an ill-conceived OQL query from
causing a deserialization, so be careful.

[[httpsession-gemfire-serialization-java-data-pdx]]
===== _Data Serialization_ + PDX + _Java Serialization_

It is possible for {data-store-name} to support all 3 serialization formats simultaneously.

For instance, your application domain model might contain objects that implement the `java.io.Serialiable` interface,
and you may be using a combination of the _Data Serialization_ framework along with PDX.

TIP: While using _Java Serialization_ with _Data Serialization_ and PDX is possible, it is generally preferable
and recommended to use 1 serialization strategy.

NOTE: Unlike _Java Serialization_, _Data Serialization_ and PDX _Serialization_ do not handle object graph cycles.

More background on {data-store-name}'s serialization mechanics can be found
{data-store-docs}/developing/data_serialization/data_serialization_options.html[here].

[[httpsession-gemfire-serialization-spring-session]]
==== Serialization with Spring Session

Previously, Spring Session for {data-store-name} only supported {data-store-name} _Data Serialization_ format. The main
motivation behind this was to take advantage of {data-store-name}'s _Delta Propagation_ functionality since a Session's
state can be arbitrarily large.

However, as of Spring Session for {data-store-name} 2.0, PDX is also supported and is now the new, default serialization
option.  The default was changed to PDX in Spring Session for {data-store-name} 2.0 primarily because PDX is the most
widely used and requested format by users.

PDX is certainly the most flexible format, so much so that you do not even need Spring Session for {data-store-name}
or any of its transitive dependencies on the classpath of the servers in the cluster to use Spring Session with
{data-store-name}.  In fact, with PDX, you do not even need to put your application domain object types stored in
the (HTTP) Session on the servers' classpath either.

Essentially, when using PDX serialization, {data-store-name} does not require the associated Java types to be present
on the servers' classpath.  So long as no deserialization happens on the servers in the cluster, you are safe.

The `@EnableGemFireHttpSession` annotation introduces the **new** `sessionSerializerBeanName` attribute that a user
can use to configure the name of a bean declared and registered in the Spring container implementing the desired
serialization strategy.  The serialization strategy is used by Spring Session for {data-store-name} to serialize
the Session state.

Out-of-the-box, Spring Session for {data-store-name} provides 2 serialization strategies: 1 for PDX and 1 for
_Data Serialization_.  It automatically registers both serialization strategy beans in the Spring container.
However, only 1 of those strategies is actually used at runtime, PDX!

The 2 beans registered in the Spring container implementing _Data Serialization_ and PDX are named
`SessionDataSerializer` and `SessionPdxSerializer`, respectively. By default, the `sessionSerializerBeanName` attribute
is set to `SessionPdxSerializer`, as if the user annotated his/her Spring Boot, Spring Session enabled application
configuration class with:

[source, java]
----
@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = "SessionPdxSerializer")
class MySpringSessionApplication { .. }
----

It is a simple matter to change the serialization strategy to _Data Serialization_ instead by setting the
`sessionSerializerBeanName` attribute to `SessionDataSerializer`, as follows:

[source, java]
----
@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = "SessionDataSerializer")
class MySpringSessionApplication { .. }
----

Since these 2 values are so common, Spring Session for {data-store-name} provides constants for each value in the
`GemFireHttpSessionConfiguration` class: `GemFireHttpSessionConfiguration.SESSION_PDX_SERIALIZER_BEAN_NAME`
and `GemFireHttpSessionConfiguration.SESSION_DATA_SERIALIZER_BEAN_NAME`.  So, you could explicitly configure PDX,
as follows:

[source, java]
----
import org.springframework.session.data.geode.config.annotation.web.http.GemFireHttpSessionConfiguration;

@SpringBootApplication
@EnableGemFireHttpSession(sessionSerializerBeanName = GemFireHttpSessionConfiguration.SESSION_PDX_SERIALIZER_BEAN_NAME)
class MySpringSessionApplication { .. }
----

With 1 attribute and 2 provided bean definitions out-of-the-box, you can specify which Serialization framework you wish
to use with your Spring Boot, Spring Session enabled application backed by {data-store-name}.

[[httpsession-gemfire-serialization-framework]]
==== Spring Session for {data-store-name} Serialization Framework

To abstract away the details of {data-store-name}'s _Data Serialization_ and PDX _Serialization_ frameworks,
Spring Session for {data-store-name} provides its own Serialization framework (facade) wrapping {data-store-name}'s
Serialization frameworks.

The Serialization API exists under the `org.springframework.session.data.gemfire.serialization` package. The primary
interface in this API is the `org.springframework.session.data.gemfire.serialization.SessionSerializer`.

The interface is defined as:

.Spring Session `SessionSerializer` interface
[source, java]
----
interface SessionSerializer<T, IN, OUT> {

  void serialize(T session, OUT out);

  T deserialize(IN in);

  boolean canSerialize(Class<?> type);

  boolean canSerialize(Object obj) {
    // calls Object.getClass() in a null-safe way and then calls and returns canSerialize(:Class)
  }
}
----

Basically, the interface allows you to serialize and deserialize a Spring `Session` object.

The `IN` and `OUT` type parameters and corresponding method arguments of those types provide reference to the objects
responsible for writing the `Session` to a stream of bytes or reading the `Session` from a stream of bytes.  The actual
arguments will be type specific, based on the underlying {data-store-name} Serialization strategy configured.

For instance, when using {data-store-name}'s PDX _Serialization_ framework, `IN` and `OUT` will be instances of
`org.apache.geode.pdx.PdxReader` and `org.apache.geode.pdx.PdxWriter`, respectively.  When {data-store-name}'s
_Data Serialization_ framework has been configured, then `IN` and `OUT` will be instances of `java.io.DataInput`
and `java.io.DataOutput`, respectively.

These arguments are provided to the `SessionSerializer` implementation by the framework automatically, and as
previously mentioned, is based on the underlying {data-store-name} Serialization strategy configured.

Essentially, even though Spring Session for {data-store-name} provides a facade around {data-store-name}'s
Serialization frameworks, under-the-hood {data-store-name} still expects one of these Serialization frameworks
is being used to serialize data to/from {data-store-name}.

_So what purpose does the `SessionSerializer` interface really serve then?_

Effectively, it allows a user to customize what aspects of the Session's state actually gets serialized and stored
in {data-store-name}.  Application developers can provide their own custom, application-specific `SessionSerializer`
implementation, register it as a bean in the Spring container, and then configure it to be used by Spring Session
for {data-store-name} to serialize the Session state, as follows:

[source, java]
----
@EnableGemFireHttpSession(sessionSerializerBeanName = "MyCustomSessionSerializer")
class MySpringSessionDataGemFireApplication {

  @Bean("MyCustomSessionSerializer")
  SessionSerializer<Session, ?, ?> myCustomSessionSerializer() {
    ...
  }
}
----

[[httpsession-gemfire-serialization-framework-serializer-implementation]]
===== Implementing a SessionSerializer

Spring Session for {data-store-name} provides assistance when a user wants to implement a custom `SessionSerializer`
that fits into one of {data-store-name}'s Serialization frameworks.

If the user just implements the `org.springframework.session.data.gemfire.serialization.SessionSerializer` interface
directly without extending from one of Spring Session for {data-store-name}'s provided abstract base classes, related
to 1 of {data-store-name}'s Serialization frameworks , then Spring Session for {data-store-name} will wrap the user's
custom `SessionSerializer` implementation in an instance of
`org.springframework.session.data.gemfire.serialization.pdx.support.PdxSerializerSessionSerializerAdapter`
and register it with {data-store-name} as a `org.apache.geode.pdx.PdxSerializer`.

Spring Session for {data-store-name} is careful not to stomp on any existing `PdxSerializer` implementation that a user
may have already registered with {data-store-name} by some other means.  Indeed, several different, provided
implementations of {data-store-name}'s `org.apache.geode.pdx.PdxSerializer` interface exists:

* {data-store-name} itself provides the
{data-store-javadoc}/org/apache/geode/pdx/ReflectionBasedAutoSerializer.html[`org.apache.geode.pdx.ReflectionBasedAutoSerializer`].

* Spring Data for {data-store-name} (SDG) provides the
{sdg-javadoc}/org/springframework/data/gemfire/mapping/MappingPdxSerializer.html[`org.springframework.data.gemfire.mapping.MappingPdxSerializer`],
which is used in the SD _Repository_ abstraction and SDG's extension to handle mapping PDX serialized types to
the application domain object types defined in the application _Repository_ interfaces.

This is accomplished by obtaining any currently registered `PdxSerializer` instance on the cache and composing it
with the `PdxSerializerSessionSerializerAdapter` wrapping the user's custom application `SessionSerializer`
implementation and re-registering this "_composite_" `PdxSerializer` on the {data-store-name} cache.  The "_composite_"
`PdxSerializer` implementation is provided by Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.pdx.support.ComposablePdxSerializer` class
when entities are stored in {data-store-name} as PDX.

If no other `PdxSerializer` was currently registered with the {data-store-name} cache, then the adapter
is simply registered.

Of course, you are allowed to force the underlying {data-store-name} Serialization strategy used with a custom
`SessionSerializer` implementation by doing 1 of the following:

1. The custom `SessionSerializer` implementation can implement {data-store-name}'s `org.apache.geode.pdx.PdxSerializer`
interface, or for convenience, extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.pdx.AbstractPdxSerializableSessionSerializer` class
and Spring Session for {data-store-name} will register the custom `SessionSerializer` as a `PdxSerializer`
with {data-store-name}.

2. The custom `SessionSerializer` implementation can extend the {data-store-name}'s `org.apache.geode.DataSerializer`
class, or for convenience, extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.data.AbstractDataSerializableSessionSerializer` class
and Spring Session for {data-store-name} will register the custom `SessionSerializer` as a `DataSerializer`
with {data-store-name}.

3. Finally, a user can create a custom `SessionSerializer` implementation as before, not specifying which
{data-store-name} Serialization framework to use because the custom `SessionSeriaizer` implementation does not implement
any {data-store-name} serialization interfaces or extend from any of Spring Session for {data-store-name}'s provided
abstract base classes, and still have it registered in {data-store-name} as a `DataSerializer` by declaring an
additional Spring Session for {data-store-name} bean in the Spring container of type
`org.springframework.session.data.gemfire.serialization.data.support.DataSerializerSessionSerializerAdapter`, like so...

.Forcing the registration of a custom SessionSerializer as a DataSerializer in {data-store-name}
[source, java]
----
@EnableGemFireHttpSession(sessionSerializerBeanName = "customSessionSerializer")
class Application {

	@Bean
	DataSerializerSessionSerializerAdapter dataSerializerSessionSerializer() {
		return new DataSerializerSessionSerializerAdapter();
	}

	@Bean
	SessionSerializer<Session, ?, ?> customSessionSerializer() {
		...
	}
}
----

Just by the very presence of the `DataSerializerSessionSerializerAdapter` registered as a bean in the Spring container,
any neutral custom `SessionSerializer` implementation will be treated and registered as a `DataSerializer`
in {data-store-name}.

[[httpsession-gemfire-serialization-framework-data-serialization-support]]
===== Additional Support for Data Serialization

NOTE: Please feel free to skip this section if you are configuring and bootstraping {data-store-name} servers
in your cluster using Spring (Boot) since generally, the information that follows will not apply.  Of course,
it all depends on your declared dependencies and your Spring configuration.  However, if you are using *_Gfsh_*
to start the servers in your cluster, then definitely read on.

====== Background

When using {data-store-name}'s _DataSerialization_ framework, especially from the client when serializing (HTTP) Session
state to the servers in the cluster, you must take care to configure the {data-store-name} servers in your cluster
with the appropriate dependencies.  This is especially true when leveraging deltas as explained in the earlier section
on <<httpsession-gemfire-serialization-data>>.

When using the _DataSerialization_ framework as your serialization strategy to serialize (HTTP) Session state from
your Web application clients to the servers, then the servers must be properly configured with the Spring Session
for {data-store-name} class types used to represent the (HTTP) Session and its contents. This means including
the Spring JARs on the servers classpath.

Additionally, using _DataSerialization_ may also require you to include the JARs containing your application domain
classes that are used by your Web application and put into the (HTTP) Session as Session Attribute values,
particularly if:

1. Your types implement the `org.apache.geode.DataSerializable` interface.
2. Your types implement the `org.apache.geode.Delta` interface.
3. You have registered a `org.apache.geode.DataSerializer` that identifies and serializes the types.
4. Your types implement the `java.io.Serializable` interface.

Of course, you must ensure your application domain object types put in the (HTTP) Session are serializable in some
form or another. However, you are not strictly required to use _DataSerialization_ nor are you necessarily
required to have your application domain object types on the servers classpath if:

1. Your types implement the `org.apache.geode.pdx.PdxSerializable` interface.
2. Or, you have registered an `org.apache.geode.pdx.PdxSerializer` that properly identifies and serializes
your application domain object types.

{data-store-name} will apply the following order of precedence when determining the serialization strategy to use
to serialize an object graph:

1. First, `DataSerializable` objects and/or any registered `DataSerializers` identifying the objects to serialize.
2. Then `PdxSerializable` objects and/or any registered `PdxSerializer` identifying the objects to serialize.
3. And finally, all `java.io.Serializable` types.

This also means that if a particular application domain object type (e.g. `A`) implements `java.io.Serializable`,
however, a (custom) `PdxSerializer` has been registered with {data-store-name} identifying the same application
domain object type (i.e. `A`), then {data-store-name} will use PDX to serialize "A" and *not* Java Serialization,
in this case.

This is especially useful since then you can use _DataSerialization_ to serialize the (HTTP) Session object, leveraging
Deltas and all the powerful features of _DataSerialization_, but then use PDX to serialize your application domain object
types, which greatly simplifies the configuration and/or effort involved.

Now that we have a general understanding of why this support exists, how do you enable it?

====== Configuration

First, create an {data-store-name} `cache.xml`, as follows:

.{data-store-name} `cache.xml` configuration
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<cache xmlns="http://geode.apache.org/schema/cache"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
	   version="1.0">

  <initializer>
    <class-name>
      org.springframework.session.data.gemfire.serialization.data.support.DataSerializableSessionSerializerInitializer
    </class-name>
  </initializer>

</cache>

----

Then, start your servers in _*Gfsh*_ using:

.Starting Server with Gfsh
[source,txt]
----
gfsh> start server --name=InitializedServer --cache-xml-file=/path/to/cache.xml --classpath=...
----

Configuring the {data-store-name} server `classpath` with the appropriate dependencies is the tricky part,
but generally, the following should work:

.CLASSPATH configuration
[source,txt]
[subs="verbatim,attributes"]
----

set variable --name=REPO_HOME --value=${USER_HOME}/.m2/repository

gfsh> start server ... --classpath=\
${REPO_HOME}/org/springframework/spring-core/{spring-version}/spring-core-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-aop/{spring-version}/spring-aop-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-beans/{spring-version}/spring-beans-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-context/{spring-version}/spring-context-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-context-support/{spring-version}/spring-context-support-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-expression/{spring-version}/spring-expression-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-jcl/{spring-version}/spring-jcl-{spring-version}.jar\
:${REPO_HOME}/org/springframework/spring-tx/{spring-version}/spring-tx-{spring-version}.jar\
:${REPO_HOME}/org/springframework/data/spring-data-commons/{spring-data-commons-version}/spring-data-commons-{spring-data-commons-version}.jar\
:${REPO_HOME}/org/springframework/data/spring-data-geode/{spring-data-geode-version}/spring-data-geode-{spring-data-geode-version}.jar\
:${REPO_HOME}/org/springframework/session/spring-session-core/{spring-session-core-version}/spring-session-core-{spring-session-core-version}.jar\
:${REPO_HOME}/org/springframework/session/spring-session-data-geode/{spring-session-data-geode-version}/spring-session-data-geode-{spring-session-data-geode-version}.jar\
:${REPO_HOME}/org/slf4j/slf4j-api/1.7.25/slf4j-api-1.7.25.jar
----

Keep in mind, you may need to add your application domain object JAR files to the server classpath as well.

To get a complete picture of how this works, see the {gh-samples-url}boot/gemfire-with-gfsh-servers[sample].

[[httpsession-gemfire-serialization-framework-session-deltas]]
===== Customizing Change Detection

By default, anytime the Session is modified (e.g. the `lastAccessedTime` is updated to the current time), the Session
is considered dirty by Spring Session for {data-store-name} (SSDG). When using {data-store-name} _Data Serialization_
framework, it is extremely useful and valuable to take advantage of {data-store-name}'s
{data-store-docs}/developing/delta_propagation/chapter_overview.html[Delta Propagation] capabilities as well.

When using _Data Serialization_, SSDG also uses _Delta Propagation_ to send only changes to the Session state between
the client and server.  This includes any Session attributes that may have been added, removed or updated.

By default, anytime `Session.setAttribute(name, value)` is called, the Session attribute is considered "dirty"
and will be sent in the delta between the client and server.  This is true even if your application domain object
has not been changed.

Typically, there is never a reason to call `Session.setAttribute(..)` unless your object has been changed.  However,
if this can occur, and your objects are relatively large (with a complex object hierarchy), then you may want to
consider either:

1. Implementing the {data-store-javadoc}/org/apache/geode/Delta.html[Delta] interface in your application domain object
model, while useful, is very invasive, or...

2. Provide a custom implementation of SSDG's `org.springframework.session.data.gemfire.support.IsDirtyPredicate`
strategy interface.

Out of the box, SSDG provides 5 implementations of the `IsDirtyPredicate` strategy interface:

[cols="2,4,1", options="header"]
.`IsDirtyPredicate` implementations
|===
| Class | Description | Default

| `IsDirtyPredicate.ALWAYS_DIRTY` | New Session attribute values are always considered dirty. |

| `IsDirtyPredicate.NEVER_DIRTY`  | New Session attribute values are never considered dirty. |

| `DeltaAwareDirtyPredicate` | New Session attribute values are considered dirty when the old value and new value
are different, if the new value's type does not implement `Delta` or the new value's `Delta.hasDelta()`
method returns *true*. | Yes

| `EqualsDirtyPredicate` | New Session attribute values are considered dirty iff the old value is not equal to
the new value as determined by `Object.equals(:Object)` method. |

| `IdentityEqualsPredicate` | New Session attributes values are considered dirty iff the old value is not the same as
  the new value using the identity equals operator (i.e. `oldValue != newValue`). |

|===

As shown in the table above, the `DeltaAwareDirtyPredicate` is the *default* implementation used by SSDG.
The `DeltaAwareDirtyPredicate` automatically takes into consideration application domain objects that implement
the {data-store-name} `Delta` interface.  However, `DeltaAwareDirtyPredicate` works even when your application
domain objects do not implement the `Delta` interface. SSDG will consider your application domain object to be dirty
anytime the `Session.setAttribute(name, newValue)` is called providing the new value is not the same as old value,
or the new value does not implement the `Delta` interface.

You can change SSDG's dirty implementation, determination strategy simply by declaring a bean in the Spring container
of the `IsDirtyPredicate` interface type:

.Overriding SSDG's default `IsDirtyPredicate` strategy
[source,java]
----
@EnableGemFireHttpSession
class ApplicationConfiguration {

  @Bean
  IsDirtyPredicate equalsDirtyPredicate() {
    return EqualsDirtyPredicate.INSTANCE;
  }

  ...
}
----

====== Composition

The `IsDirtyPredicate` interface also provides the `andThen(:IsDirtyPredicate)` and `orThen(:IsDirtyPredicate)` methods
to compose 2 or more `IsDirtyPredicate` implementations in a composition in order to organize complex logic and rules
for determining whether an application domain object is dirty or not.

For instance, you could compose both `EqualsDirtyPredicate` and `DeltaAwareDirtyPredicate` using the OR operator:

.Composing `EqualsDirtyPredicate` with `DeltaAwareDirtyPredicate` using the logical OR operator
[source,java]
----
@EnableGemFireHttpSession
class ApplicationConfiguration {

  @Bean
  IsDirtyPredicate equalsOrThenDeltaDirtyPredicate() {

    return EqualsDirtyPredicate.INSTANCE
      .orThen(DeltaAwareDirtyPredicate.INSTANCE);
  }

  ...
}
----

You may even implement your own, custom `IsDirtyPredicates` based on specific application domain object types:

.Application Domain Object Type-specific `IsDirtyPredicate` implementations
[source,java]
----

class CustomerDirtyPredicate implements IsDirtyPredicate {

  public boolean isDirty(Object oldCustomer, Object newCustomer) {

      if (newCustomer instanceof Customer) {
        // custom logic to determine if a new Customer is dirty
      }

      return true;
  }
}

class AccountDirtyPredicate implements IsDirtyPredicate {

  public boolean isDirty(Object oldAccount, Object newAccount) {

      if (newAccount instanceof Account) {
        // custom logic to determine if a new Account is dirty
      }

      return true;
  }
}
----

Then combine `CustomerDirtyPredicate` with the `AccountDirtyPredicate` and a default predicate for fallback, as follows:

.Composed and configured type-specific `IsDirtyPredicates`
[source,java]
----
@EnableGemFireHttpSession
class ApplicationConfiguration {

  @Bean
  IsDirtyPredicate typeSpecificDirtyPredicate() {

    return new CustomerDirtyPredicate()
      .andThen(new AccountDirtyPredicate())
      .andThen(IsDirtyPredicate.ALWAYS_DIRTY);
  }

  ...
}
----

The combinations and possibilities are endless.

WARNING: Use caution when implementing custom `IsDirtyPredicate` strategies.  If you incorrectly determine that your
application domain object is not dirty when it actually is, then it will not be sent in the Session delta
from the client to the server.

[[httpsession-gemfire-serialization-framework-session-representation]]
===== Changing the Session Representation

Internally, Spring Session for {data-store-name} maintains 2 representations of the (HTTP) Session and the Session's
attributes.  Each representation is based on whether {data-store-name} "_Deltas_" are supported or not.

{data-store-name} _Delta Propagation_ is only enabled by Spring Session for {data-store-name} when using
_Data Serialization_ for reasons that were discussed <<httpsession-gemfire-serialization-pdx, earlier>>.

Effectively, the strategy is:

1. If {data-store-name} _Data Serialization_ is configured, then _Deltas_ are supported and the
`DeltaCapableGemFireSession` and `DeltaCapableGemFireSessionAttributes` representations are used.

2. If {data-store-name} PDX _Serialization_ is configured, then _Delta Propagation_ will be disabled
and the `GemFireSession` and `GemFireSessionAttributes` representations are used.

It is possible to override these internal representations used by Spring Session for {data-store-name}, and for users
to provide their own Session related types.  The only strict requirement is that the Session implementation
must implement the core Spring Session `org.springframework.session.Session` interface.

By way of example, let's say you want to define your own Session implementation.

First, you define the `Session` type.  Perhaps your custom `Session` type even encapsulates and handles the Session
attributes without having to define a separate type.

.User-defined Session interface implementation
[source, java]
----
class MySession implements org.springframework.session.Session {
  ...
}
----

Then, you would need to extend the `org.springframework.session.data.gemfire.GemFireOperationsSessionRepository` class
and override the `createSession()` method to create instances of your custom `Session` implementation class.

.Custom SessionRepository implementation creating and returning instances of the custom Session type
[source, java]
----
class MySessionRepository extends GemFireOperationsSessionRepository {

  @Override
  public Session createSession() {
    return new MySession();
  }
}
----

If you provide your own custom `SessionSerializer` implementation and {data-store-name} PDX _Serialization_ is
configured, then you done.

However, if you configured {data-store-name} _Data Serialization_ then you must additionally provide a custom
implementation of the `SessionSerializer` interface and either have it directly extend {data-store-name}'s
`org.apache.geode.DataSerializer` class, or extend Spring Session for {data-store-name}'s
`org.springframework.session.data.gemfire.serialization.data.AbstractDataSerializableSessionSerializer` class
and override the `getSupportedClasses():Class<?>[]` method.

For example:

.Custom SessionSerializer for custom Session type
[source, java]
----
class MySessionSerializer extends AbstractDataSerializableSessionSerializer {

  @Override
  public Class<?>[] getSupportedClasses() {
    return new Class[] { MySession.class };
  }

  ...
}
----

Unfortunately, `getSupportedClasses()` cannot return the generic Spring Session `org.springframework.session.Session`
interface type.  If it could then we could avoid the explicit need to override the `getSupportedClasses()` method on
the custom `DataSerializer` implementation.  But, {data-store-name}'s _Data Serialization_ framework  can only match
on exact class types since it incorrectly and internally stores and refers to the class type by name, which then
requires the user to override and implement the `getSupportedClasses()` method.

[[httpsession-how]]
=== How HttpSession Integration Works

Fortunately, both `javax.servlet.http.HttpSession` and `javax.servlet.http.HttpServletRequest` (the API for
obtaining an `HttpSession`) are interfaces. This means we can provide our own implementations for each of these APIs.

NOTE: This section describes how Spring Session provides transparent integration with `javax.servlet.http.HttpSession`.
The intent is so users understand what is happening under-the-hood. This functionality is already implemented
and integrated so you do not need to implement this logic yourself.

First, we create a custom `javax.servlet.http.HttpServletRequest` that returns a custom implementation of
`javax.servlet.http.HttpSession`.  It looks something like the following:

[source, java]
----
public class SessionRepositoryRequestWrapper extends HttpServletRequestWrapper {

	public SessionRepositoryRequestWrapper(HttpServletRequest original) {
		super(original);
	}

	public HttpSession getSession() {
		return getSession(true);
	}

	public HttpSession getSession(boolean createNew) {
		// create an HttpSession implementation from Spring Session
	}

	// ... other methods delegate to the original HttpServletRequest ...
}
----

Any method that returns an `javax.servlet.http.HttpSession` is overridden.  All other methods are implemented by
`javax.servlet.http.HttpServletRequestWrapper` and simply delegate to the original
`javax.servlet.http.HttpServletRequest` implementation.

We replace the `javax.servlet.http.HttpServletRequest` implementation using a Servlet `Filter` called
`SessionRepositoryFilter`. The pseudocode can be found below:

[source, java]
----
public class SessionRepositoryFilter implements Filter {

	public doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {

		HttpServletRequest httpRequest = (HttpServletRequest) request;

		SessionRepositoryRequestWrapper customRequest = new SessionRepositoryRequestWrapper(httpRequest);

		chain.doFilter(customRequest, response, chain);
	}

	// ...
}
----

By passing in a custom `javax.servlet.http.HttpServletRequest` implementation into the `FilterChain` we ensure that
anything invoked after our `Filter` uses the custom `javax.servlet.http.HttpSession` implementation.

This highlights why it is important that Spring Session's `SessionRepositoryFilter` must be placed before anything
that interacts with the `javax.servlet.http.HttpSession`.

[[httpsession-httpsessionlistener]]
=== HttpSessionListener

Spring Session supports `HttpSessionListener` by translating `SessionCreatedEvent` and `SessionDestroyedEvent` into
`HttpSessionEvent` by declaring `SessionEventHttpSessionListenerAdapter`.

To use this support, you need to:

* Ensure your `SessionRepository` implementation supports and is configured to fire `SessionCreatedEvent`
and`SessionDestroyedEvent`.
* Configure `SessionEventHttpSessionListenerAdapter` as a Spring bean.
* Inject every `HttpSessionListener` into the `SessionEventHttpSessionListenerAdapter`

If you are using the configuration support documented in <<httpsession-gemfire,HttpSession with {data-store-name}>>,
then all you need to do is register every `HttpSessionListener` as a bean.

For example, assume you want to support Spring Security's concurrency control and need to use `HttpSessionEventPublisher`,
then you can simply add `HttpSessionEventPublisher` as a bean.

[[api-session]]
=== Session

A `Session` is a simplified `Map` of key/value pairs with support for expiration.

[[api-sessionrepository]]
=== SessionRepository

A `SessionRepository` is in charge of creating, persisting and accessing `Session` instances and state.

If possible, developers should not interact directly with a `SessionRepository` or a `Session`.  Instead, developers
should prefer to interact with `SessionRepository` and `Session` indirectly through the `javax.servlet.http.HttpSession`,
`WebSocket` and `WebSession` integration.

[[api-findbyindexnamesessionrepository]]
=== FindByIndexNameSessionRepository

Spring Session's most basic API for using a `Session` is the `SessionRepository`.  The API is intentionally very simple
so that it is easy to provide additional implementations with basic functionality.

Some `SessionRepository` implementations may choose to implement `FindByIndexNameSessionRepository` also.
For example, Spring Session's for {data-store-name} support implements `FindByIndexNameSessionRepository`.

The `FindByIndexNameSessionRepository` adds a single method to look up all the sessions for a particular user.
This is done by ensuring that the session attribute with the name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`
is populated with the username. It is the responsibility of the developer to ensure the attribute is populated since
Spring Session is not aware of the authentication mechanism being used.

[NOTE]
====
Some implementations of `FindByIndexNameSessionRepository` will provide hooks to automatically index other session attributes.
For example, many implementations will automatically ensure the current Spring Security user name is indexed with
the index name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`.
====

[[api-enablespringhttpsession]]
=== EnableSpringHttpSession

The `@EnableSpringHttpSession` annotation can be added to any `@Configuration` class to expose the
`SessionRepositoryFilter` as a bean in the Spring container named, "springSessionRepositoryFilter".

In order to leverage the annotation, a single `SessionRepository` bean must be provided.

[[api-enablegemfirehttpsession]]
=== EnableGemFireHttpSession

The `@EnableGemFireHttpSession` annotation can be added to any `@Configuration` class in place of the
`@EnableSpringHttpSession` annotation to expose the `SessionRepositoryFilter` as a bean in the Spring container named,
"springSessionRepositoryFilter" and to position {data-store-name} as a provider managing `javax.servlet.http.HttpSession`
state.

When using the `@EnableGemFireHttpSession` annotation, additional configuration is imported out-of-the-box that also
provides a {data-store-name} specific implementation of the `SessionRepository` interface named,
`GemFireOperationsSessionRepository`.

[[api-gemfireoperationssessionrepository]]
=== GemFireOperationsSessionRepository

`GemFireOperationsSessionRepository` is a `SessionRepository` implementation that is implemented using Spring Session
for {data-store-name}'s_ `GemFireOperationsSessionRepository`.

In a web environment, this repository is used in conjunction with the `SessionRepositoryFilter`.

This implementation supports `SessionCreatedEvents`, `SessionDeletedEvents` and `SessionDestroyedEvents`
through `SessionEventHttpSessionListenerAdapter`.

[[api-gemfireoperationssessionrepository-indexing]]
==== Using Indexes with {data-store-name}

While best practices concerning the proper definition of Indexes that positively impact {data-store-name}'s performance
is beyond the scope of this document, it is important to realize that Spring Session for {data-store-name} creates
and uses Indexes to query and find Sessions efficiently.

Out-of-the-box, Spring Session for {data-store-name} creates 1 Hash-typed Index on the principal name. There are two
different built-in strategies for finding the principal name. The first strategy is that the value of the Session
attribute with the name `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME` will be Indexed to the same
index name.

For example:

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyindexname-set]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyindexname-get]
----

[[api-gemfireoperationssessionrepository-indexing-security]]
==== Using Indexes with {data-store-name} & Spring Security

Alternatively, Spring Session for {data-store-name} will map Spring Security's current `Authentication#getName()` to
the Index `FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME`.

For example, if you are using Spring Security you can find the current user's sessions using:

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyspringsecurityindexname-context]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireIndexingIntegrationTests.java[tags=findbyspringsecurityindexname-get]
----

[[api-gemfireoperationssessionrepository-indexing-custom]]
==== Using Custom Indexes with {data-store-name}

This enables developers using the `GemFireOperationsSessionRepository` programmatically to query and find all Sessions
with a given principal name efficiently.

Additionally, Spring Session for {data-store-name} will create a Range-based Index on the implementing Session's
Map-type `attributes` property (i.e. on any arbitrary Session attribute) when a developer identifies 1 or more
named Session attributes that should be indexed by {data-store-name}.

Sessions attributes to index can be specified with the `indexableSessionAttributes` attribute on the
`@EnableGemFireHttpSession` annotation.  A developer adds this annotation to their Spring application
`@Configuration` class when s/he wishes to enable Spring Session's support for `HttpSession` backed by
{data-store-name}.

[source,java,indent=0]
----
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireCustomIndexingIntegrationTests.java[tags=findbyindexname-set]
include::{docs-itest-dir}docs/gemfire/indexing/HttpSessionGemFireCustomIndexingIntegrationTests.java[tags=findbyindexname-get]
----

NOTE: Only Session attribute names identified in the `@EnableGemFireHttpSession` annotation's
`indexableSessionAttributes` attribute will have an Index defined.  All other Session attributes will not be indexed.

However, there is one catch. Any values stored in an indexable Session attributes must implement the
`java.lang.Comparable<T>` interface. If those object values do not implement `Comparable`, then {data-store-name}
will throw an error on startup when the Index is defined for Regions with persistent Session data, or when an attempt
is made at runtime to assign the indexable Session attribute a value that is not `Comparable` and the Session is saved
to {data-store-name}.

NOTE: Any Session attribute that is not indexed may store non-`Comparable` values.

To learn more about {data-store-name}'s Range-based Indexes, see
{data-store-docs}/developing/query_index/creating_map_indexes.html[Creating Indexes on Map Fields].

To learn more about {data-store-name} Indexing in general, see
{data-store-docs}/developing/query_index/query_index.html[Working with Indexes].

[[community]]
== Spring Session Community

We are glad to consider you a part of our community.
Please find additional information below.

[[community-support]]
=== Support

You can get help by asking questions on http://stackoverflow.com/questions/tagged/spring-session[StackOverflow with the tag `spring-session`].
Similarly we encourage helping others by answering questions on _StackOverflow_.

[[community-source]]
=== Source Code

The source code can be found on GitHub at https://github.com/spring-projects/spring-session-data-geode

[[community-issues]]
=== Issue Tracking

We track issues in GitHub Issues at https://github.com/spring-projects/spring-session-data-geode/issues

[[community-contributing]]
=== Contributing

We appreciate https://help.github.com/articles/using-pull-requests/[Pull Requests].

[[community-license]]
=== License

Spring Session for {data-store-name} and Spring Session for Pivotal GemFire are Open Source Software
released under the http://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 license].

[[minimum-requirements]]
== Minimum Requirements

The minimum requirements for Spring Session are:

* Java 8+
* If you are running in a Servlet container (not required), Servlet 2.5+
* If you are using other Spring libraries (not required), the minimum required version is Spring Framework 5.0.x.
* `@EnableGemFireHttpSession` requires Spring Data for {data-store-name} 2.0.x and Spring Data for Pivotal GemFire 2.0.x.
* `@EnableGemFireHttpSession` requires {data-store-name} 1.2.x or Pivotal GemFire 9.1.x.

[NOTE]
====
At its core Spring Session only has a required dependency on `spring-jcl`.
====
